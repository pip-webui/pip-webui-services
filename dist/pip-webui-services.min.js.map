{"version":3,"sources":["../node_modules/browser-pack/_prelude.js","../node_modules/async/dist/async.js","../node_modules/process/browser.js","src/index.ts","src/routing/BackDecorator.ts","src/routing/RoutingEvents.ts","src/routing/index.ts","src/session/IdentityService.ts","src/session/SessionService.ts","src/session/index.ts","src/transactions/Transaction.ts","src/transactions/TransactionError.ts","src/transactions/TransactionService.ts","src/transactions/TransactionStrings.ts","src/transactions/index.ts","src/translate/TranslateDirective.ts","src/translate/TranslateFilter.ts","src/translate/Translation.ts","src/translate/TranslateService.ts","src/translate/index.ts","src/utilities/Codes.ts","src/utilities/Format.ts","src/utilities/PageResetService.ts","src/utilities/ScrollService.ts","src/utilities/SystemInfo.ts","src/utilities/Tags.ts","src/utilities/TimerService.ts","src/utilities/index.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","pip","services","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","factory","async","apply","func","thisArg","args","overRest$1","start","transform","nativeMax","undefined","arguments","index","array","Array","otherArgs","identity","value","rest","isObject","type","asyncify","initialParams","callback","result","then","err","message","supportsAsync","supported","isAsync","eval","fn","supportsSymbol","Symbol","toStringTag","wrapAsync","asyncFn","applyEach$1","eachfn","fns","go","that","cb","wrapAsync$1","concat","getRawTag","isOwn","hasOwnProperty","symToStringTag$1","tag","nativeObjectToString","objectToString","nativeObjectToString$1","baseGetTag","undefinedTag","nullTag","Object","symToStringTag","isFunction","funcTag","genTag","asyncTag","proxyTag","isLength","MAX_SAFE_INTEGER","isArrayLike","noop","once","callFn","baseTimes","iteratee","isObjectLike","baseIsArguments","argsTag","stubFalse","isIndex","MAX_SAFE_INTEGER$1","reIsUint","test","baseIsTypedArray","typedArrayTags","baseUnary","arrayLikeKeys","inherited","isArr","isArray","isArg","isArguments","isBuff","isBuffer","isType","isTypedArray","skipIndexes","String","key","hasOwnProperty$1","push","isPrototype","Ctor","constructor","prototype","objectProto$5","overArg","arg","baseKeys","object","nativeKeys","hasOwnProperty$3","keys","createArrayIterator","coll","len","createES2015Iterator","iterator","item","next","done","createObjectIterator","obj","okeys","getIterator","onlyOnce","_eachOfLimit","limit","iterateeCallback","running","breakLoop","replenish","elem","nextElem","eachOfLimit","doLimit","iterable","eachOfArrayLike","iteratorCallback","completed","doParallel","eachOf","_asyncMap","arr","results","counter","_iteratee","_","v","doParallelLimit","arrayEach","createBaseFor","fromRight","keysFunc","props","baseForOwn","baseFor","baseFindIndex","predicate","fromIndex","baseIsNaN","strictIndexOf","baseIndexOf","arrayMap","isSymbol","symbolTag","baseToString","symbolToString","INFINITY","baseSlice","end","castSlice","charsEndIndex","strSymbols","chrSymbols","charsStartIndex","asciiToArray","string","split","hasUnicode","reHasUnicode","unicodeToArray","match","reUnicode","stringToArray","toString","trim","chars","guard","replace","reTrim","join","parseParams","STRIP_COMMENTS","FN_ARGS","FN_ARG_SPLIT","map","FN_ARG","autoInject","tasks","newTasks","taskFn","newTask","taskCb","newArgs","params","name","fnIsAsync","hasNoDeps","slice","pop","auto","fallback","setTimeout","wrap","defer","DLL","head","tail","setInitial","dll","node","queue","worker","concurrency","payload","_insert","data","insertAtFront","q","started","idle","setImmediate$1","drain","_tasks","unshift","process","_next","numRunning","task","workersList","splice","error","buffer","unsaturated","_worker","isProcessing","saturated","empty","paused","kill","Math","min","shift","pause","resume","cargo","reduce","memo","eachOfSeries","x","concat$1","y","doSeries","_createTester","check","getResult","testResult","testPassed","_findGetResult","consoleFunc","console","doDuring","truth","_fn","_test","doWhilst","doUntil","during","_withoutIndex","eachLimit","eachLimit$1","ensureAsync","sync","innerArgs","notId","baseProperty","filterArray","truthValues","filterGeneric","sort","b","_filter","forever","errback","mapValuesLimit","newObj","val","has","memoize","hasher","create","queues","memoized","unmemoized","_parallel","parallelLimit","parallelLimit$1","race","TypeError","reduceRight","reverse","reflect","reflectCallback","cbArgs","reject$1","reflectAll","constant$1","retry","opts","retryAttempt","_task","attempt","options","times","errorFilter","intervalFunc","DEFAULT_TIMES","DEFAULT_INTERVAL","acc","interval","series","sortBy","comparator","left","right","criteria","timeout","milliseconds","info","injectedCallback","timedOut","originalCallback","clearTimeout","timer","timeoutCallback","origCallback","baseRange","step","nativeMax$1","nativeCeil","timeLimit","count","mapLimit","accumulator","k","unmemoize","whilst","until","max","freeGlobal","freeSelf","root","Function","Symbol$1","objectProto","objectProto$1","iteratorSymbol","objectProto$3","hasOwnProperty$2","propertyIsEnumerable","freeExports","nodeType","freeModule","moduleExports","Buffer","nativeIsBuffer","argsTag$1","arrayTag","boolTag","dateTag","errorTag","funcTag$1","mapTag","numberTag","objectTag","regexpTag","setTag","stringTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","freeExports$1","freeModule$1","moduleExports$1","freeProcess","nodeUtil","binding","nodeIsTypedArray","objectProto$2","objectProto$4","eachOfGeneric","Infinity","applyEach","mapSeries","applyEachSeries","apply$2","callArgs","enqueueTask","readyTasks","runTask","processQueue","runningTasks","addListener","taskName","taskListeners","listeners","taskComplete","hasError","taskCallback","safeResults","rkey","getDependents","keys$$1","numTasks","readyToCheck","uncheckedDependencies","dependencies","remainingDependencies","dependencyName","currentTask","dependent","symbolProto","rsAstralRange","rsComboMarksRange","rsComboSymbolsRange","rsVarRange","rsZWJ","RegExp","rsAstralRange$1","rsComboMarksRange$1","rsComboSymbolsRange$1","rsVarRange$1","rsAstral","rsCombo","rsFitz","rsModifier","rsNonAstral","rsRegional","rsSurrPair","rsZWJ$1","reOptMod","rsOptVar","rsOptJoin","rsSeq","rsSymbol","hasSetImmediate","setImmediate","hasNextTick","nextTick","_defer","removeLink","prev","insertAfter","newNode","insertBefore","seq$1","functions","_functions","newargs","nextargs","compose","concatSeries","constant","values","ignoredArgs","detect","detectLimit","detectSeries","dir","eachSeries","every","everyLimit","everySeries","filter","filterLimit","filterSeries","groupByLimit","mapResults","groupBy","groupBySeries","log","mapValues","mapValuesSeries","_defer$1","queue$1","items","priorityQueue","priority","nextNode","reject","rejectLimit","rejectSeries","retryable","some","Boolean","someLimit","someSeries","ceil","timesSeries","waterfall","nextTask","taskIndex","each","parallel","seq","timesLimit","all","any","forEach","forEachSeries","forEachLimit","forEachOf","forEachOfSeries","forEachOfLimit","inject","foldl","foldr","select","selectLimit","selectSeries","wrapSync","allLimit","allSeries","anyLimit","anySeries","find","findLimit","findSeries","defineProperty","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","run","Item","title","browser","env","argv","version","versions","on","off","removeListener","removeAllListeners","emit","cwd","chdir","umask","angular","__export","captureStateTranslations","$rootScope","$on","event","toState","toParams","fromState","fromParams","CurrentState","url","PreviousState","StateVar","PrevStateVar","decorateBackStateService","$delegate","$window","goBack","history","back","goBackAndSelect","state","cloneDeep","extend","addBackStateDecorator","$provide","decorator","$inject","5","hookRoutingEvents","$log","$state","RoutingVar","m","p","./BackDecorator","./RoutingEvents","7","IdentityRootVar","IdentityChangedEvent","IdentityService","setRootVar","_setRootVar","_identity","_rootScope","_log","debug","JSON","stringify","enumerable","configurable","IdentityProvider","_service","$get","provider","8","SessionRootVar","SessionOpenedEvent","SessionClosedEvent","SessionService","session","notifyError","_session","notifyListeners","successCallback","listener","notifyOpenListeners","_this","notifyCloseListeners","$emit","stop","oldSession","addOpenListener","addCloseListener","removeOpenListener","removeCloseListener","isOpened","open","close","SessionProvider","./IdentityService","./SessionService","10","Transaction","scope","_scope","_id","_operation","_error","TransactionError_1","TransactionError","_progress","reset","busy","failed","aborted","id","begin","operation","Date","getTime","update","progress","abort","decode","11","details","cause","stack_trace","statusText","status","12","Transaction_1","TransactionService","_transactions","transaction","get","service","13","configureTransactionStrings","$injector","setTranslations","ENTERING","PROCESSING","LOADING","SAVING","./TransactionError","./TransactionService","./TransactionStrings","15","translateDirective","pipTranslate","key1","key2","link","element","attrs","translate","text","translateHtmlDirective","html","directive","16","optionalTranslateFilter","translateFilter","initTranslate","language","extendStatics","setPrototypeOf","__proto__","d","__","LanguageRootVar","LanguageChangedEvent","TranslateService","translation","persist","$mdDateLocale","_persist","_translation","_window","_mdDateLocale","localStorage","getItem","changeLocale","save","locale","localeDate","moment","localeData","months","_months","format","shortMonths","_monthsShort","days","_weekdays","shortDays","_weekdaysMin","firstDayOfWeek","_week","dow","setItem","PageResetService_1","ResetPageEvent","use","translations","translateArray","translateSet","keyProp","valueProp","translateObjects","translateWithPrefix","prefix","translateSetWithPrefix","translateSetWithPrefix2","_super","TranslateProvider","set","./Translation","18","Translation","_language","en","ru","es","pt","de","fr","_translations","isNull","isUndefined","toUpperCase","19","./TranslateFilter","./TranslateService","20","Codes","hash","charCodeAt","random","substr","Format","cache","sample","maxLength","indexOf","substring","strRepeat","str","qty","getType","variable","toLowerCase","parseFormat","fmt","parse_tree","arg_names","exec","_fmt","replacement_field","field_match","field_list","tree_length","node_type","cursor","sprintf","fromCharCode","parseInt","toExponential","parseFloat","toFixed","abs","pad_character","charAt","pad_length","output","pad","_i","filterToString","arrayToString","enumToArray","hookResetEvents","pipPageReset","ResetAreaEvent","area","resetArea","ResetRootVar","ResetAreaRootVar","PageResetService","$timeout","_timeout","performReset","scrollTo","parentElement","childElement","animationDuration","$","position","scrollTop","top","ScrollService","SystemInfo","ua","navigator","userAgent","search","browserName","subVersion","osAll","osAndroid","isDesktop","platform","isMobile","isCordova","isSupported","edge","ie","firefox","opera","chrome","safari","Tags","normalizeOne","compressOne","equal","tag1","tag2","normalizeAll","tags","isString","compressAll","extract","entity","searchFields","field","hashTags","uniq","26","TimerEvent","DefaultEvents","TimerService","$interval","_started","_events","_interval","isStarted","addEvent","newEvent","startEvent","removeEvent","existingEvent","stopEvent","clearEvents","cancel","ex"],"mappings":"CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,MAAAJ,EAAAK,MAAAL,EAAAK,SAAAC,SAAAX,MAAA,WAAA,GAAAG,QAAAD,OAAAD,OAAA,OAAA,SAAAW,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAjB,GAAA,GAAAsB,OAAA,uBAAAL,EAAA,IAAA,MAAAjB,GAAAuB,KAAA,mBAAAvB,EAAA,GAAAwB,GAAAV,EAAAG,IAAAhB,WAAAY,GAAAI,GAAA,GAAAQ,KAAAD,EAAAvB,QAAA,SAAAW,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,GAAAF,IAAAY,EAAAA,EAAAvB,QAAAW,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAhB,QAAA,IAAA,GAAAoB,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,QAAAlB,OAAAD,oCCAA,SAAAM,EAAAqB,GACA,gBAAA3B,cAAA,KAAAC,OAAA0B,EAAA3B,SACA,kBAAAE,SAAAA,OAAAC,IAAAD,QAAA,WAAAyB,GACAA,EAAArB,EAAAsB,MAAAtB,EAAAsB,YACApB,KAAA,SAAAR,SAAA,YAYA,SAAA6B,OAAAC,EAAAC,EAAAC,GACA,OAAAA,EAAAP,QACA,IAAA,GAAA,MAAAK,GAAAN,KAAAO,EACA,KAAA,GAAA,MAAAD,GAAAN,KAAAO,EAAAC,EAAA,GACA,KAAA,GAAA,MAAAF,GAAAN,KAAAO,EAAAC,EAAA,GAAAA,EAAA,GACA,KAAA,GAAA,MAAAF,GAAAN,KAAAO,EAAAC,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAEA,MAAAF,GAAAD,MAAAE,EAAAC,GAeA,QAAAC,YAAAH,EAAAI,EAAAC,GAEA,MADAD,GAAAE,cAAAC,KAAAH,EAAAJ,EAAAL,OAAA,EAAAS,EAAA,GACA,WAMA,IALA,GAAAF,GAAAM,UACAC,GAAA,EACAd,EAAAW,UAAAJ,EAAAP,OAAAS,EAAA,GACAM,EAAAC,MAAAhB,KAEAc,EAAAd,GACAe,EAAAD,GAAAP,EAAAE,EAAAK,EAEAA,IAAA,CAEA,KADA,GAAAG,GAAAD,MAAAP,EAAA,KACAK,EAAAL,GACAQ,EAAAH,GAAAP,EAAAO,EAGA,OADAG,GAAAR,GAAAC,EAAAK,GACAX,MAAAC,EAAAtB,KAAAkC,IAoBA,QAAAC,UAAAC,GACA,MAAAA,GAKA,QAAAC,MAAAf,EAAAI,GACA,MAAAD,YAAAH,EAAAI,EAAAS,UAmCA,QAAAG,UAAAF,GACA,GAAAG,SAAAH,EACA,OAAA,OAAAA,IAAA,UAAAG,GAAA,YAAAA,GA2DA,QAAAC,UAAAlB,GACA,MAAAmB,eAAA,SAAAjB,EAAAkB,GACA,GAAAC,EACA,KACAA,EAAArB,EAAAD,MAAArB,KAAAwB,GACA,MAAArB,GACA,MAAAuC,GAAAvC,GAGAmC,SAAAK,IAAA,kBAAAA,GAAAC,KACAD,EAAAC,KAAA,SAAAR,GACAM,EAAA,KAAAN,IACA,SAAAS,GACAH,EAAAG,EAAAC,QAAAD,EAAA,GAAAhC,OAAAgC,MAGAH,EAAA,KAAAC,KAOA,QAAAI,iBACA,GAAAC,UACA,KAEAA,UAAAC,QAAAC,KAAA,2BACA,MAAA/C,GACA6C,WAAA,EAEA,MAAAA,WAGA,QAAAC,SAAAE,GACA,MAAAC,iBAAA,kBAAAD,EAAAE,OAAAC,aAGA,QAAAC,WAAAC,GACA,MAAAP,SAAAO,GAAAhB,SAAAgB,GAAAA,EAKA,QAAAC,aAAAC,GACA,MAAArB,MAAA,SAAAsB,EAAAnC,GACA,GAAAoC,GAAAnB,cAAA,SAAAjB,EAAAkB,GACA,GAAAmB,GAAA7D,IACA,OAAA0D,GAAAC,EAAA,SAAAR,EAAAW,GACAC,YAAAZ,GAAA9B,MAAAwC,EAAArC,EAAAwC,OAAAF,KACApB,IAEA,OAAAlB,GAAAP,OACA2C,EAAAvC,MAAArB,KAAAwB,GAEAoC,IAwCA,QAAAK,WAAA7B,GACA,GAAA8B,GAAAC,eAAAnD,KAAAoB,EAAAgC,kBACAC,EAAAjC,EAAAgC,iBAEA,KACAhC,EAAAgC,sBAAAvC,GAEA,MAAA1B,IAEA,GAAAwC,GAAA2B,qBAAAtD,KAAAoB,EAQA,OANA8B,GACA9B,EAAAgC,kBAAAC,QAEAjC,GAAAgC,kBAGAzB,EAoBA,QAAA4B,gBAAAnC,GACA,MAAAoC,wBAAAxD,KAAAoB,GAiBA,QAAAqC,YAAArC,GACA,MAAA,OAAAA,MACAP,KAAAO,EAAAsC,aAAAC,SAEAvC,EAAAwC,OAAAxC,GACAyC,gBAAAA,iBAAAzC,GACA6B,UAAA7B,GACAmC,eAAAnC,IA0BA,QAAA0C,YAAA1C,GACA,IAAAE,SAAAF,GACA,OAAA,CAIA,IAAAiC,GAAAI,WAAArC,EACA,OAAAiC,IAAAU,SAAAV,GAAAW,QAAAX,GAAAY,UAAAZ,GAAAa,SAgCA,QAAAC,UAAA/C,GACA,MAAA,gBAAAA,IACAA,GAAA,GAAAA,EAAA,GAAA,GAAAA,GAAAgD,iBA4BA,QAAAC,aAAAjD,GACA,MAAA,OAAAA,GAAA+C,SAAA/C,EAAAnB,UAAA6D,WAAA1C,GAmBA,QAAAkD,SAIA,QAAAC,MAAApC,GACA,MAAA,YACA,GAAA,OAAAA,EAAA,CACA,GAAAqC,GAAArC,CACAA,GAAA,KACAqC,EAAAnE,MAAArB,KAAA8B,aAmBA,QAAA2D,WAAApF,EAAAqF,GAIA,IAHA,GAAA3D,IAAA,EACAY,EAAAV,MAAA5B,KAEA0B,EAAA1B,GACAsC,EAAAZ,GAAA2D,EAAA3D,EAEA,OAAAY,GA2BA,QAAAgD,cAAAvD,GACA,MAAA,OAAAA,GAAA,gBAAAA,GAaA,QAAAwD,iBAAAxD,GACA,MAAAuD,cAAAvD,IAAAqC,WAAArC,IAAAyD,QAyEA,QAAAC,aACA,OAAA,EAmDA,QAAAC,SAAA3D,EAAAnB,GAEA,SADAA,EAAA,MAAAA,EAAA+E,mBAAA/E,KAEA,gBAAAmB,IAAA6D,SAAAC,KAAA9D,KACAA,GAAA,GAAAA,EAAA,GAAA,GAAAA,EAAAnB,EAqDA,QAAAkF,kBAAA/D,GACA,MAAAuD,cAAAvD,IACA+C,SAAA/C,EAAAnB,WAAAmF,eAAA3B,WAAArC,IAUA,QAAAiE,WAAA/E,GACA,MAAA,UAAAc,GACA,MAAAd,GAAAc,IA2DA,QAAAkE,eAAAlE,EAAAmE,GACA,GAAAC,GAAAC,QAAArE,GACAsE,GAAAF,GAAAG,YAAAvE,GACAwE,GAAAJ,IAAAE,GAAAG,SAAAzE,GACA0E,GAAAN,IAAAE,IAAAE,GAAAG,aAAA3E,GACA4E,EAAAR,GAAAE,GAAAE,GAAAE,EACAnE,EAAAqE,EAAAvB,UAAArD,EAAAnB,OAAAgG,WACAhG,EAAA0B,EAAA1B,MAEA,KAAA,GAAAiG,KAAA9E,IACAmE,IAAAY,iBAAAnG,KAAAoB,EAAA8E,IACAF,IAEA,UAAAE,GAEAN,IAAA,UAAAM,GAAA,UAAAA,IAEAJ,IAAA,UAAAI,GAAA,cAAAA,GAAA,cAAAA,IAEAnB,QAAAmB,EAAAjG,KAEA0B,EAAAyE,KAAAF,EAGA,OAAAvE,GAaA,QAAA0E,aAAAjF,GACA,GAAAkF,GAAAlF,GAAAA,EAAAmF,WAGA,OAAAnF,MAFA,kBAAAkF,IAAAA,EAAAE,WAAAC,eAaA,QAAAC,SAAApG,EAAAK,GACA,MAAA,UAAAgG,GACA,MAAArG,GAAAK,EAAAgG,KAoBA,QAAAC,UAAAC,GACA,IAAAR,YAAAQ,GACA,MAAAC,YAAAD,EAEA,IAAAlF,KACA,KAAA,GAAAuE,KAAAtC,QAAAiD,GACAE,iBAAA/G,KAAA6G,EAAAX,IAAA,eAAAA,GACAvE,EAAAyE,KAAAF,EAGA,OAAAvE,GA+BA,QAAAqF,MAAAH,GACA,MAAAxC,aAAAwC,GAAAvB,cAAAuB,GAAAD,SAAAC,GAGA,QAAAI,qBAAAC,GACA,GAAAtH,IAAA,EACAuH,EAAAD,EAAAjH,MACA,OAAA,YACA,QAAAL,EAAAuH,GAAA/F,MAAA8F,EAAAtH,GAAAsG,IAAAtG,GAAA,MAIA,QAAAwH,sBAAAC,GACA,GAAAzH,IAAA,CACA,OAAA,YACA,GAAA0H,GAAAD,EAAAE,MACA,OAAAD,GAAAE,KAAA,MACA5H,KACAwB,MAAAkG,EAAAlG,MAAA8E,IAAAtG,KAIA,QAAA6H,sBAAAC,GACA,GAAAC,GAAAX,KAAAU,GACA9H,GAAA,EACAuH,EAAAQ,EAAA1H,MACA,OAAA,YACA,GAAAiG,GAAAyB,IAAA/H,EACA,OAAAA,GAAAuH,GAAA/F,MAAAsG,EAAAxB,GAAAA,IAAAA,GAAA,MAIA,QAAAmB,UAAAH,GACA,GAAA7C,YAAA6C,GACA,MAAAD,qBAAAC,EAGA,IAAAG,GAAAO,YAAAV,EACA,OAAAG,GAAAD,qBAAAC,GAAAI,qBAAAP,GAGA,QAAAW,UAAA1F,GACA,MAAA,YACA,GAAA,OAAAA,EAAA,KAAA,IAAAtC,OAAA,+BACA,IAAA2E,GAAArC,CACAA,GAAA,KACAqC,EAAAnE,MAAArB,KAAA8B,YAIA,QAAAgH,cAAAC,GACA,MAAA,UAAAL,EAAAhD,EAAAhD,GASA,QAAAsG,GAAAnG,EAAAT,GAEA,GADA6G,GAAA,EACApG,EACA2F,GAAA,EACA9F,EAAAG,OACA,CAAA,GAAAT,IAAA8G,WAAAV,GAAAS,GAAA,EAEA,MADAT,IAAA,EACA9F,EAAA,KAEAyG,MAIA,QAAAA,KACA,KAAAF,EAAAF,IAAAP,GAAA,CACA,GAAAY,GAAAC,GACA,IAAA,OAAAD,EAKA,MAJAZ,IAAA,OACAS,GAAA,GACAvG,EAAA,MAIAuG,IAAA,EACAvD,EAAA0D,EAAAhH,MAAAgH,EAAAlC,IAAA2B,SAAAG,KA/BA,GADAtG,EAAA6C,KAAA7C,GAAA4C,MACAyD,GAAA,IAAAL,EACA,MAAAhG,GAAA,KAEA,IAAA2G,GAAAhB,SAAAK,GACAF,GAAA,EACAS,EAAA,CA8BAE,MAwBA,QAAAG,aAAApB,EAAAa,EAAArD,EAAAhD,GACAoG,aAAAC,GAAAb,EAAAnE,YAAA2B,GAAAhD,GAGA,QAAA6G,SAAApG,EAAA4F,GACA,MAAA,UAAAS,EAAA9D,EAAAhD,GACA,MAAAS,GAAAqG,EAAAT,EAAArD,EAAAhD,IAKA,QAAA+G,iBAAAvB,EAAAxC,EAAAhD,GASA,QAAAgH,GAAA7G,EAAAT,GACAS,EACAH,EAAAG,KACA8G,IAAA1I,GAAAmB,IAAA8G,WACAxG,EAAA,MAZAA,EAAA6C,KAAA7C,GAAA4C,KACA,IAAAvD,GAAA,EACA4H,EAAA,EACA1I,EAAAiH,EAAAjH,MAaA,KAZA,IAAAA,GACAyB,EAAA,MAWAX,EAAAd,EAAAc,IACA2D,EAAAwC,EAAAnG,GAAAA,EAAA8G,SAAAa,IAmDA,QAAAE,YAAAzG,GACA,MAAA,UAAAuF,EAAAhD,EAAAhD,GACA,MAAAS,GAAA0G,OAAAnB,EAAA3E,YAAA2B,GAAAhD,IAIA,QAAAoH,WAAApG,EAAAqG,EAAArE,EAAAhD,GACAA,EAAAA,GAAA4C,KACAyE,EAAAA,KACA,IAAAC,MACAC,EAAA,EACAC,EAAAnG,YAAA2B,EAEAhC,GAAAqG,EAAA,SAAA3H,EAAA+H,EAAAzH,GACA,GAAAX,GAAAkI,GACAC,GAAA9H,EAAA,SAAAS,EAAAuH,GACAJ,EAAAjI,GAAAqI,EACA1H,EAAAG,MAEA,SAAAA,GACAH,EAAAG,EAAAmH,KA6EA,QAAAK,iBAAAlH,GACA,MAAA,UAAAuF,EAAAK,EAAArD,EAAAhD,GACA,MAAAS,GAAA2F,aAAAC,GAAAL,EAAA3E,YAAA2B,GAAAhD,IA6HA,QAAA4H,WAAAtI,EAAA0D,GAIA,IAHA,GAAA3D,IAAA,EACAd,EAAA,MAAAe,EAAA,EAAAA,EAAAf,SAEAc,EAAAd,IACA,IAAAyE,EAAA1D,EAAAD,GAAAA,EAAAC,KAIA,MAAAA,GAUA,QAAAuI,eAAAC,GACA,MAAA,UAAA3C,EAAAnC,EAAA+E,GAMA,IALA,GAAA1I,IAAA,EACAyH,EAAA5E,OAAAiD,GACA6C,EAAAD,EAAA5C,GACA5G,EAAAyJ,EAAAzJ,OAEAA,KAAA,CACA,GAAAiG,GAAAwD,EAAAF,EAAAvJ,IAAAc,EACA,KAAA,IAAA2D,EAAA8D,EAAAtC,GAAAA,EAAAsC,GACA,MAGA,MAAA3B,IAyBA,QAAA8C,YAAA9C,EAAAnC,GACA,MAAAmC,IAAA+C,QAAA/C,EAAAnC,EAAAsC,MAcA,QAAA6C,eAAA7I,EAAA8I,EAAAC,EAAAP,GAIA,IAHA,GAAAvJ,GAAAe,EAAAf,OACAc,EAAAgJ,GAAAP,EAAA,GAAA,GAEAA,EAAAzI,MAAAA,EAAAd,GACA,GAAA6J,EAAA9I,EAAAD,GAAAA,EAAAC,GACA,MAAAD,EAGA,QAAA,EAUA,QAAAiJ,WAAA5I,GACA,MAAAA,KAAAA,EAaA,QAAA6I,eAAAjJ,EAAAI,EAAA2I,GAIA,IAHA,GAAAhJ,GAAAgJ,EAAA,EACA9J,EAAAe,EAAAf,SAEAc,EAAAd,GACA,GAAAe,EAAAD,KAAAK,EACA,MAAAL,EAGA,QAAA,EAYA,QAAAmJ,aAAAlJ,EAAAI,EAAA2I,GACA,MAAA3I,KAAAA,EACA6I,cAAAjJ,EAAAI,EAAA2I,GACAF,cAAA7I,EAAAgJ,UAAAD,GA2PA,QAAAI,UAAAnJ,EAAA0D,GAKA,IAJA,GAAA3D,IAAA,EACAd,EAAA,MAAAe,EAAA,EAAAA,EAAAf,OACA0B,EAAAV,MAAAhB,KAEAc,EAAAd,GACA0B,EAAAZ,GAAA2D,EAAA1D,EAAAD,GAAAA,EAAAC,EAEA,OAAAW,GAuBA,QAAAyI,UAAAhJ,GACA,MAAA,gBAAAA,IACAuD,aAAAvD,IAAAqC,WAAArC,IAAAiJ,UAkBA,QAAAC,cAAAlJ,GAEA,GAAA,gBAAAA,GACA,MAAAA,EAEA,IAAAqE,QAAArE,GAEA,MAAA+I,UAAA/I,EAAAkJ,cAAA,EAEA,IAAAF,SAAAhJ,GACA,MAAAmJ,gBAAAA,eAAAvK,KAAAoB,GAAA,EAEA,IAAAO,GAAAP,EAAA,EACA,OAAA,KAAAO,GAAA,EAAAP,IAAAoJ,SAAA,KAAA7I,EAYA,QAAA8I,WAAAzJ,EAAAN,EAAAgK,GACA,GAAA3J,IAAA,EACAd,EAAAe,EAAAf,MAEAS,GAAA,IACAA,GAAAA,EAAAT,EAAA,EAAAA,EAAAS,GAEAgK,EAAAA,EAAAzK,EAAAA,EAAAyK,EACAA,EAAA,IACAA,GAAAzK,GAEAA,EAAAS,EAAAgK,EAAA,EAAAA,EAAAhK,IAAA,EACAA,KAAA,CAGA,KADA,GAAAiB,GAAAV,MAAAhB,KACAc,EAAAd,GACA0B,EAAAZ,GAAAC,EAAAD,EAAAL,EAEA,OAAAiB,GAYA,QAAAgJ,WAAA3J,EAAAN,EAAAgK,GACA,GAAAzK,GAAAe,EAAAf,MAEA,OADAyK,OAAA7J,KAAA6J,EAAAzK,EAAAyK,GACAhK,GAAAgK,GAAAzK,EAAAe,EAAAyJ,UAAAzJ,EAAAN,EAAAgK,GAYA,QAAAE,eAAAC,EAAAC,GAGA,IAFA,GAAA/J,GAAA8J,EAAA5K,OAEAc,KAAAmJ,YAAAY,EAAAD,EAAA9J,GAAA,IAAA,IACA,MAAAA,GAYA,QAAAgK,iBAAAF,EAAAC,GAIA,IAHA,GAAA/J,IAAA,EACAd,EAAA4K,EAAA5K,SAEAc,EAAAd,GAAAiK,YAAAY,EAAAD,EAAA9J,GAAA,IAAA,IACA,MAAAA,GAUA,QAAAiK,cAAAC,GACA,MAAAA,GAAAC,MAAA,IAsBA,QAAAC,YAAAF,GACA,MAAAG,cAAAlG,KAAA+F,GAoCA,QAAAI,gBAAAJ,GACA,MAAAA,GAAAK,MAAAC,eAUA,QAAAC,eAAAP,GACA,MAAAE,YAAAF,GACAI,eAAAJ,GACAD,aAAAC,GAwBA,QAAAQ,UAAArK,GACA,MAAA,OAAAA,EAAA,GAAAkJ,aAAAlJ,GA4BA,QAAAsK,MAAAT,EAAAU,EAAAC,GAEA,IADAX,EAAAQ,SAAAR,MACAW,OAAA/K,KAAA8K,GACA,MAAAV,GAAAY,QAAAC,OAAA,GAEA,KAAAb,KAAAU,EAAArB,aAAAqB,IACA,MAAAV,EAEA,IAAAJ,GAAAW,cAAAP,GACAH,EAAAU,cAAAG,EAIA,OAAAhB,WAAAE,EAHAE,gBAAAF,EAAAC,GACAF,cAAAC,EAAAC,GAAA,GAEAiB,KAAA,IAQA,QAAAC,aAAA1L,GAOA,MANAA,GAAAA,EAAAmL,WAAAI,QAAAI,eAAA,IACA3L,EAAAA,EAAAgL,MAAAY,SAAA,GAAAL,QAAA,IAAA,IACAvL,EAAAA,EAAAA,EAAA4K,MAAAiB,iBACA7L,EAAAA,EAAA8L,IAAA,SAAAzF,GACA,MAAA+E,MAAA/E,EAAAkF,QAAAQ,OAAA,OAuFA,QAAAC,YAAAC,EAAA7K,GACA,GAAA8K,KAEA7C,YAAA4C,EAAA,SAAAE,EAAAvG,GAyBA,QAAAwG,GAAA1D,EAAA2D,GACA,GAAAC,GAAAzC,SAAA0C,EAAA,SAAAC,GACA,MAAA9D,GAAA8D,IAEAF,GAAAxG,KAAAuG,GACA5J,YAAA0J,GAAApM,MAAA,KAAAuM,GA7BA,GAAAC,GACAE,EAAA9K,QAAAwK,GACAO,GAAAD,GAAA,IAAAN,EAAAxM,QAAA8M,GAAA,IAAAN,EAAAxM,MAEA,IAAAwF,QAAAgH,GACAI,EAAAJ,EAAAQ,MAAA,GAAA,GACAR,EAAAA,EAAAA,EAAAxM,OAAA,GAEAuM,EAAAtG,GAAA2G,EAAA7J,OAAA6J,EAAA5M,OAAA,EAAAyM,EAAAD,OACA,IAAAO,EAEAR,EAAAtG,GAAAuG,MACA,CAEA,GADAI,EAAAb,YAAAS,GACA,IAAAA,EAAAxM,SAAA8M,GAAA,IAAAF,EAAA5M,OACA,KAAA,IAAAJ,OAAA,yDAIAkN,IAAAF,EAAAK,MAEAV,EAAAtG,GAAA2G,EAAA7J,OAAA0J,MAYAS,KAAAX,EAAA9K,GAMA,QAAA0L,UAAAjL,GACAkL,WAAAlL,EAAA,GAGA,QAAAmL,MAAAC,GACA,MAAAlM,MAAA,SAAAc,EAAA3B,GACA+M,EAAA,WACApL,EAAA9B,MAAA,KAAAG,OAqBA,QAAAgN,OACAxO,KAAAyO,KAAAzO,KAAA0O,KAAA,KACA1O,KAAAiB,OAAA,EAGA,QAAA0N,YAAAC,EAAAC,GACAD,EAAA3N,OAAA,EACA2N,EAAAH,KAAAG,EAAAF,KAAAG,EA8CA,QAAAC,OAAAC,EAAAC,EAAAC,GAWA,QAAAC,GAAAC,EAAAC,EAAA1M,GACA,GAAA,MAAAA,GAAA,kBAAAA,GACA,KAAA,IAAA7B,OAAA,mCAMA,IAJAwO,EAAAC,SAAA,EACA7I,QAAA0I,KACAA,GAAAA,IAEA,IAAAA,EAAAlO,QAAAoO,EAAAE,OAEA,MAAAC,gBAAA,WACAH,EAAAI,SAIA,KAAA,GAAA7O,GAAA,EAAAG,EAAAoO,EAAAlO,OAAAL,EAAAG,EAAAH,IAAA,CACA,GAAA0H,IACA6G,KAAAA,EAAAvO,GACA8B,SAAAA,GAAA4C,KAGA8J,GACAC,EAAAK,OAAAC,QAAArH,GAEA+G,EAAAK,OAAAtI,KAAAkB,GAGAkH,eAAAH,EAAAO,SAGA,QAAAC,GAAAtC,GACA,MAAAlL,MAAA,SAAAb,GACAsO,GAAA,CAEA,KAAA,GAAAlP,GAAA,EAAAG,EAAAwM,EAAAtM,OAAAL,EAAAG,EAAAH,IAAA,CACA,GAAAmP,GAAAxC,EAAA3M,GACAmB,EAAAmJ,YAAA8E,EAAAD,EAAA,EACAhO,IAAA,GACAiO,EAAAC,OAAAlO,GAGAgO,EAAArN,SAAArB,MAAA0O,EAAAvO,GAEA,MAAAA,EAAA,IACA6N,EAAAa,MAAA1O,EAAA,GAAAuO,EAAAZ,MAIAW,GAAAT,EAAAL,YAAAK,EAAAc,QACAd,EAAAe,cAGAf,EAAAE,QACAF,EAAAI,QAEAJ,EAAAO,YAjEA,GAAA,MAAAZ,EACAA,EAAA,MACA,IAAA,IAAAA,EACA,KAAA,IAAAnO,OAAA,+BAGA,IAAAwP,GAAAtM,YAAAgL,GACAe,EAAA,EACAE,KA6DAM,GAAA,EACAjB,GACAK,OAAA,GAAAlB,KACAQ,YAAAA,EACAC,QAAAA,EACAsB,UAAAjL,KACA8K,YAAA9K,KACA6K,OAAAnB,EAAA,EACAwB,MAAAlL,KACAmK,MAAAnK,KACA4K,MAAA5K,KACAgK,SAAA,EACAmB,QAAA,EACArJ,KAAA,SAAA+H,EAAAzM,GACAwM,EAAAC,GAAA,EAAAzM,IAEAgO,KAAA,WACArB,EAAAI,MAAAnK,KACA+J,EAAAK,OAAAc,SAEAb,QAAA,SAAAR,EAAAzM,GACAwM,EAAAC,GAAA,EAAAzM,IAEAkN,QAAA,WAGA,IAAAU,EAAA,CAIA,IADAA,GAAA,GACAjB,EAAAoB,QAAAX,EAAAT,EAAAL,aAAAK,EAAAK,OAAAzO,QAAA,CACA,GAAAsM,MACA4B,KACApO,EAAAsO,EAAAK,OAAAzO,MACAoO,GAAAJ,UAAAlO,EAAA4P,KAAAC,IAAA7P,EAAAsO,EAAAJ,SACA,KAAA,GAAArO,GAAA,EAAAA,EAAAG,EAAAH,IAAA,CACA,GAAAiO,GAAAQ,EAAAK,OAAAmB,OACAtD,GAAAnG,KAAAyH,GACAM,EAAA/H,KAAAyH,EAAAM,MAGA,IAAAE,EAAAK,OAAAzO,QACAoO,EAAAmB,QAEAV,GAAA,EACAE,EAAA5I,KAAAmG,EAAA,IAEAuC,IAAAT,EAAAL,aACAK,EAAAkB,WAGA,IAAAzM,GAAA+E,SAAAgH,EAAAtC,GACA8C,GAAAlB,EAAArL,GAEAwM,GAAA,IAEArP,OAAA,WACA,MAAAoO,GAAAK,OAAAzO,QAEAgI,QAAA,WACA,MAAA6G,IAEAE,YAAA,WACA,MAAAA,IAEAT,KAAA,WACA,MAAAF,GAAAK,OAAAzO,OAAA6O,IAAA,GAEAgB,MAAA,WACAzB,EAAAoB,QAAA,GAEAM,OAAA,YACA,IAAA1B,EAAAoB,SAGApB,EAAAoB,QAAA,EACAjB,eAAAH,EAAAO,WAGA,OAAAP,GAgFA,QAAA2B,OAAAjC,EAAAE,GACA,MAAAH,OAAAC,EAAA,EAAAE,GA8DA,QAAAgC,QAAA/I,EAAAgJ,EAAAxL,EAAAhD,GACAA,EAAA6C,KAAA7C,GAAA4C,KACA,IAAA4E,GAAAnG,YAAA2B,EACAyL,cAAAjJ,EAAA,SAAAkJ,EAAAxQ,EAAA8B,GACAwH,EAAAgH,EAAAE,EAAA,SAAAvO,EAAAuH,GACA8G,EAAA9G,EACA1H,EAAAG,MAEA,SAAAA,GACAH,EAAAG,EAAAqO,KAuGA,QAAAG,UAAA3N,EAAAqG,EAAA5G,EAAAT,GACA,GAAAC,KACAe,GAAAqG,EAAA,SAAAqH,EAAArP,EAAA+B,GACAX,EAAAiO,EAAA,SAAAvO,EAAAyO,GACA3O,EAAAA,EAAAqB,OAAAsN,OACAxN,EAAAjB,MAEA,SAAAA,GACAH,EAAAG,EAAAF,KA+BA,QAAA4O,UAAApO,GACA,MAAA,UAAAuF,EAAAhD,EAAAhD,GACA,MAAAS,GAAAgO,aAAAzI,EAAA3E,YAAA2B,GAAAhD,IAyEA,QAAA8O,eAAAC,EAAAC,GACA,MAAA,UAAAhO,EAAAqG,EAAArE,EAAA5B,GACAA,EAAAA,GAAAwB,IACA,IACAqM,GADAC,GAAA,CAEAlO,GAAAqG,EAAA,SAAA3H,EAAA+H,EAAAzH,GACAgD,EAAAtD,EAAA,SAAAS,EAAAF,GACAE,EACAH,EAAAG,GACA4O,EAAA9O,KAAAgP,GACAC,GAAA,EACAD,EAAAD,GAAA,EAAAtP,GACAM,EAAA,KAAAwG,YAEAxG,OAGA,SAAAG,GACAA,EACAiB,EAAAjB,GAEAiB,EAAA,KAAA8N,EAAAD,EAAAD,GAAA,OAMA,QAAAG,gBAAAzH,EAAAgH,GACA,MAAAA,GAsFA,QAAAU,aAAAhE,GACA,MAAAzL,MAAA,SAAAc,EAAA3B,GACAuC,YAAAZ,GAAA9B,MAAA,KAAAG,EAAAwC,OAAA3B,KAAA,SAAAQ,EAAArB,GACA,gBAAAuQ,WACAlP,EACAkP,QAAA7B,OACA6B,QAAA7B,MAAArN,GAEAkP,QAAAjE,IACAxD,UAAA9I,EAAA,SAAA4P,GACAW,QAAAjE,GAAAsD,YA2DA,QAAAY,UAAA7O,EAAA+C,EAAAxD,GAWA,QAAA+O,GAAA5O,EAAAoP,GACA,MAAApP,GAAAH,EAAAG,GACAoP,MACAC,GAAA3J,GADA7F,EAAA,MAZAA,EAAAmG,SAAAnG,GAAA4C,KACA,IAAA4M,GAAAnO,YAAAZ,GACAgP,EAAApO,YAAAmC,GAEAqC,EAAAlG,KAAA,SAAAQ,EAAArB,GACA,GAAAqB,EAAA,MAAAH,GAAAG,EACArB,GAAA4F,KAAAqK,GACAU,EAAA9Q,MAAArB,KAAAwB,IASAiQ,GAAA,MAAA,GAyBA,QAAAW,UAAA1M,EAAAQ,EAAAxD,GACAA,EAAAmG,SAAAnG,GAAA4C,KACA,IAAA4E,GAAAnG,YAAA2B,GACA6C,EAAAlG,KAAA,SAAAQ,EAAArB,GACA,MAAAqB,GAAAH,EAAAG,GACAqD,EAAA7E,MAAArB,KAAAwB,GAAA0I,EAAA3B,OACA7F,GAAArB,MAAA,MAAA,MAAA2C,OAAAxC,KAEA0I,GAAA3B,GAuBA,QAAA8J,SAAA3M,EAAAQ,EAAAxD,GACA0P,SAAA1M,EAAA,WACA,OAAAQ,EAAA7E,MAAArB,KAAA8B,YACAY,GAuCA,QAAA4P,QAAApM,EAAA/C,EAAAT,GAKA,QAAA6F,GAAA1F,GACA,GAAAA,EAAA,MAAAH,GAAAG,EACAsP,GAAAV,GAGA,QAAAA,GAAA5O,EAAAoP,GACA,MAAApP,GAAAH,EAAAG,GACAoP,MACAC,GAAA3J,GADA7F,EAAA,MAXAA,EAAAmG,SAAAnG,GAAA4C,KACA,IAAA4M,GAAAnO,YAAAZ,GACAgP,EAAApO,YAAAmC,EAaAiM,GAAAV,GAGA,QAAAc,eAAA7M,GACA,MAAA,UAAAtD,EAAAL,EAAAW,GACA,MAAAgD,GAAAtD,EAAAM,IA6DA,QAAA8P,WAAAtK,EAAAxC,EAAAhD,GACAmH,OAAA3B,EAAAqK,cAAAxO,YAAA2B,IAAAhD,GAuBA,QAAA+P,aAAAvK,EAAAa,EAAArD,EAAAhD,GACAoG,aAAAC,GAAAb,EAAAqK,cAAAxO,YAAA2B,IAAAhD,GA2DA,QAAAgQ,aAAAvP,GACA,MAAAF,SAAAE,GAAAA,EACAV,cAAA,SAAAjB,EAAAkB,GACA,GAAAiQ,IAAA,CACAnR,GAAA4F,KAAA,WACA,GAAAwL,GAAA9Q,SACA6Q,GACAnD,eAAA,WACA9M,EAAArB,MAAA,KAAAuR,KAGAlQ,EAAArB,MAAA,KAAAuR,KAGAzP,EAAA9B,MAAArB,KAAAwB,GACAmR,GAAA,IAIA,QAAAE,OAAAzI,GACA,OAAAA,EAmFA,QAAA0I,cAAA5L,GACA,MAAA,UAAAW,GACA,MAAA,OAAAA,MAAAhG,GAAAgG,EAAAX,IAIA,QAAA6L,aAAArP,EAAAqG,EAAArE,EAAAhD,GACA,GAAAsQ,GAAA,GAAA/Q,OAAA8H,EAAA9I,OACAyC,GAAAqG,EAAA,SAAAqH,EAAArP,EAAAW,GACAgD,EAAA0L,EAAA,SAAAvO,EAAAuH,GACA4I,EAAAjR,KAAAqI,EACA1H,EAAAG,MAEA,SAAAA,GACA,GAAAA,EAAA,MAAAH,GAAAG,EAEA,KAAA,GADAmH,MACApJ,EAAA,EAAAA,EAAAmJ,EAAA9I,OAAAL,IACAoS,EAAApS,IAAAoJ,EAAA5C,KAAA2C,EAAAnJ,GAEA8B,GAAA,KAAAsH,KAIA,QAAAiJ,eAAAvP,EAAAwE,EAAAxC,EAAAhD,GACA,GAAAsH,KACAtG,GAAAwE,EAAA,SAAAkJ,EAAArP,EAAAW,GACAgD,EAAA0L,EAAA,SAAAvO,EAAAuH,GACAvH,EACAH,EAAAG,IAEAuH,GACAJ,EAAA5C,MAAArF,MAAAA,EAAAK,MAAAgP,IAEA1O,QAGA,SAAAG,GACAA,EACAH,EAAAG,GAEAH,EAAA,KAAAyI,SAAAnB,EAAAkJ,KAAA,SAAAxS,EAAAyS,GACA,MAAAzS,GAAAqB,MAAAoR,EAAApR,QACA+Q,aAAA,aAKA,QAAAM,SAAA1P,EAAAwE,EAAAxC,EAAAhD,IACA2C,YAAA6C,GAAA6K,YAAAE,eACAvP,EAAAwE,EAAAnE,YAAA2B,GAAAhD,GAAA4C,MAqGA,QAAA+N,SAAAlQ,EAAAmQ,GAIA,QAAA/K,GAAA1F,GACA,GAAAA,EAAA,MAAA2F,GAAA3F,EACAkN,GAAAxH,GALA,GAAAC,GAAAK,SAAAyK,GAAAhO,MACAyK,EAAAhM,YAAA2O,YAAAvP,GAMAoF,KAiKA,QAAAgL,gBAAA7K,EAAAK,EAAArD,EAAAhD,GACAA,EAAA6C,KAAA7C,GAAA4C,KACA,IAAAkO,MACAtJ,EAAAnG,YAAA2B,EACA4D,aAAAZ,EAAAK,EAAA,SAAA0K,EAAAvM,EAAAqB,GACA2B,EAAAuJ,EAAAvM,EAAA,SAAArE,EAAAF,GACA,GAAAE,EAAA,MAAA0F,GAAA1F,EACA2Q,GAAAtM,GAAAvE,EACA4F,OAEA,SAAA1F,GACAH,EAAAG,EAAA2Q,KAwEA,QAAAE,KAAAhL,EAAAxB,GACA,MAAAA,KAAAwB,GAwCA,QAAAiL,SAAAxQ,EAAAyQ,GACA,GAAA1C,GAAAtM,OAAAiP,OAAA,MACAC,EAAAlP,OAAAiP,OAAA,KACAD,GAAAA,GAAAzR,QACA,IAAA+P,GAAAnO,YAAAZ,GACA4Q,EAAAtR,cAAA,SAAAjB,EAAAkB,GACA,GAAAwE,GAAA0M,EAAAvS,MAAA,KAAAG,EACAkS,KAAAxC,EAAAhK,GACAsI,eAAA,WACA9M,EAAArB,MAAA,KAAA6P,EAAAhK,MAEAwM,IAAAI,EAAA5M,GACA4M,EAAA5M,GAAAE,KAAA1E,IAEAoR,EAAA5M,IAAAxE,GACAwP,EAAA7Q,MAAA,KAAAG,EAAAwC,OAAA3B,KAAA,SAAAb,GACA0P,EAAAhK,GAAA1F,CACA,IAAA6N,GAAAyE,EAAA5M,SACA4M,GAAA5M,EACA,KAAA,GAAAtG,GAAA,EAAAG,EAAAsO,EAAApO,OAAAL,EAAAG,EAAAH,IACAyO,EAAAzO,GAAAS,MAAA,KAAAG,SAOA,OAFAuS,GAAA7C,KAAAA,EACA6C,EAAAC,WAAA7Q,EACA4Q,EA8CA,QAAAE,WAAAvQ,EAAA6J,EAAA7K,GACAA,EAAAA,GAAA4C,IACA,IAAA0E,GAAA3E,YAAAkI,QAEA7J,GAAA6J,EAAA,SAAAwC,EAAA7I,EAAAxE,GACAqB,YAAAgM,GAAA1N,KAAA,SAAAQ,EAAArB,GACAA,EAAAP,QAAA,IACAO,EAAAA,EAAA,IAEAwI,EAAA9C,GAAA1F,EACAkB,EAAAG,OAEA,SAAAA,GACAH,EAAAG,EAAAmH,KAyEA,QAAAkK,eAAA3G,EAAA7K,GACAuR,UAAApK,OAAA0D,EAAA7K,GAsBA,QAAAyR,iBAAA5G,EAAAxE,EAAArG,GACAuR,UAAAnL,aAAAC,GAAAwE,EAAA7K,GAwNA,QAAA0R,MAAA7G,EAAA7K,GAEA,GADAA,EAAA6C,KAAA7C,GAAA4C,OACAmB,QAAA8G,GAAA,MAAA7K,GAAA,GAAA2R,WAAA,wDACA,KAAA9G,EAAAtM,OAAA,MAAAyB,IACA,KAAA,GAAA9B,GAAA,EAAAG,EAAAwM,EAAAtM,OAAAL,EAAAG,EAAAH,IACAmD,YAAAwJ,EAAA3M,IAAA8B,GA4BA,QAAA4R,aAAAtS,EAAAkP,EAAAxL,EAAAhD,GAEAuO,OADAhD,MAAAjN,KAAAgB,GAAAuS,UACArD,EAAAxL,EAAAhD,GA0CA,QAAA8R,SAAArR,GACA,GAAA+O,GAAAnO,YAAAZ,EACA,OAAAV,eAAA,SAAAjB,EAAAiT,GAmBA,MAlBAjT,GAAA4F,KAAA/E,KAAA,SAAAQ,EAAA6R,GACA,GAAA7R,EACA4R,EAAA,MACAvE,MAAArN,QAEA,CACA,GAAAT,GAAA,IACA,KAAAsS,EAAAzT,OACAmB,EAAAsS,EAAA,GACAA,EAAAzT,OAAA,IACAmB,EAAAsS,GAEAD,EAAA,MACArS,MAAAA,QAKA8P,EAAA7Q,MAAArB,KAAAwB,KAIA,QAAAmT,UAAAjR,EAAAqG,EAAArE,EAAAhD,GACA0Q,QAAA1P,EAAAqG,EAAA,SAAA3H,EAAA0B,GACA4B,EAAAtD,EAAA,SAAAS,EAAAuH,GACAtG,EAAAjB,GAAAuH,MAEA1H,GAmGA,QAAAkS,YAAArH,GACA,GAAAvD,EASA,OARAvD,SAAA8G,GACAvD,EAAAmB,SAAAoC,EAAAiH,UAEAxK,KACAW,WAAA4C,EAAA,SAAAwC,EAAA7I,GACA8C,EAAA9C,GAAAsN,QAAAxT,KAAAhB,KAAA+P,MAGA/F,EA8DA,QAAA6K,YAAAzS,GACA,MAAA,YACA,MAAAA,IAwFA,QAAA0S,OAAAC,EAAAhF,EAAArN,GAsCA,QAAAsS,KACAC,EAAA,SAAApS,GACAA,GAAAqS,IAAAC,EAAAC,QAAA,kBAAAD,GAAAE,aAAAF,EAAAE,YAAAxS,IACAwL,WAAA2G,EAAAG,EAAAG,aAAAJ,IAEAxS,EAAArB,MAAA,KAAAS,aA1CA,GAAAyT,GAAA,EACAC,EAAA,EAEAL,GACAC,MAAAG,EACAD,aAAAT,WAAAW,GAyBA,IARA1T,UAAAb,OAAA,GAAA,kBAAA8T,IACArS,EAAAqN,GAAAzK,KACAyK,EAAAgF,KAhBA,SAAAU,EAAArV,GACA,GAAA,gBAAAA,GACAqV,EAAAL,OAAAhV,EAAAgV,OAAAG,EAEAE,EAAAH,aAAA,kBAAAlV,GAAAsV,SAAAtV,EAAAsV,SAAAb,YAAAzU,EAAAsV,UAAAF,GAEAC,EAAAJ,YAAAjV,EAAAiV,gBACA,CAAA,GAAA,gBAAAjV,IAAA,gBAAAA,GAGA,KAAA,IAAAS,OAAA,oCAFA4U,GAAAL,OAAAhV,GAAAmV,IAUAJ,EAAAJ,GACArS,EAAAA,GAAA4C,MAGA,kBAAAyK,GACA,KAAA,IAAAlP,OAAA,oCAGA,IAAAoU,GAAAlR,YAAAgM,GAEAmF,EAAA,CAWAF,KA8GA,QAAAW,QAAApI,EAAA7K,GACAuR,UAAA9C,aAAA5D,EAAA7K,GA+HA,QAAAkT,QAAA1N,EAAAxC,EAAAhD,GAYA,QAAAmT,GAAAC,EAAAC,GACA,GAAArV,GAAAoV,EAAAE,SACA7C,EAAA4C,EAAAC,QACA,OAAAtV,GAAAyS,GAAA,EAAAzS,EAAAyS,EAAA,EAAA,EAdA,GAAAjJ,GAAAnG,YAAA2B,EACA0H,KAAAlF,EAAA,SAAAkJ,EAAA1O,GACAwH,EAAAkH,EAAA,SAAAvO,EAAAmT,GACA,GAAAnT,EAAA,MAAAH,GAAAG,EACAH,GAAA,MAAAN,MAAAgP,EAAA4E,SAAAA,OAEA,SAAAnT,EAAAmH,GACA,GAAAnH,EAAA,MAAAH,GAAAG,EACAH,GAAA,KAAAyI,SAAAnB,EAAAkJ,KAAA2C,GAAA/C,aAAA,aAmDA,QAAAmD,SAAAzS,EAAA0S,EAAAC,GAIA,QAAAC,KACAC,IACAC,EAAAjV,MAAA,KAAAS,WACAyU,aAAAC,IAIA,QAAAC,KACA,GAAA3I,GAAAtK,EAAAsK,MAAA,YACAoC,EAAA,GAAArP,OAAA,sBAAAiN,EAAA,eACAoC,GAAApP,KAAA,YACAqV,IACAjG,EAAAiG,KAAAA,GAEAE,GAAA,EACAC,EAAApG,GAlBA,GAAAoG,GAAAE,EACAH,GAAA,EAoBAlT,EAAAY,YAAAP,EAEA,OAAAf,eAAA,SAAAjB,EAAAkV,GACAJ,EAAAI,EAEAF,EAAAnI,WAAAoI,EAAAP,GACA/S,EAAA9B,MAAA,KAAAG,EAAAwC,OAAAoS,MAmBA,QAAAO,WAAAjV,EAAAgK,EAAAkL,EAAApM,GAKA,IAJA,GAAAzI,IAAA,EACAd,EAAA4V,YAAAC,YAAApL,EAAAhK,IAAAkV,GAAA,IAAA,GACAjU,EAAAV,MAAAhB,GAEAA,KACA0B,EAAA6H,EAAAvJ,IAAAc,GAAAL,EACAA,GAAAkV,CAEA,OAAAjU,GAmBA,QAAAoU,WAAAC,EAAAjO,EAAArD,EAAAhD,GACA,GAAAwH,GAAAnG,YAAA2B,EACAuR,UAAAN,UAAA,EAAAK,EAAA,GAAAjO,EAAAmB,EAAAxH,GA+FA,QAAAf,WAAAuG,EAAAgP,EAAAxR,EAAAhD,GACAZ,UAAAb,QAAA,IACAyB,EAAAgD,EACAA,EAAAwR,EACAA,EAAAzQ,QAAAyB,UAEAxF,EAAA6C,KAAA7C,GAAA4C,KACA,IAAA4E,GAAAnG,YAAA2B,EAEAmE,QAAA3B,EAAA,SAAAkC,EAAA+M,EAAArT,GACAoG,EAAAgN,EAAA9M,EAAA+M,EAAArT,IACA,SAAAjB,GACAH,EAAAG,EAAAqU,KAiBA,QAAAE,WAAAjU,GACA,MAAA,YACA,OAAAA,EAAA6Q,YAAA7Q,GAAA9B,MAAA,KAAAS,YAsCA,QAAAuV,QAAAnR,EAAAR,EAAAhD,GACAA,EAAAmG,SAAAnG,GAAA4C,KACA,IAAA4E,GAAAnG,YAAA2B,EACA,KAAAQ,IAAA,MAAAxD,GAAA,KACA,IAAA6F,GAAAlG,KAAA,SAAAQ,EAAArB,GACA,MAAAqB,GAAAH,EAAAG,GACAqD,IAAAgE,EAAA3B,OACA7F,GAAArB,MAAA,MAAA,MAAA2C,OAAAxC,KAEA0I,GAAA3B,GAyBA,QAAA+O,OAAApR,EAAAR,EAAAhD,GACA2U,OAAA,WACA,OAAAnR,EAAA7E,MAAArB,KAAA8B,YACA4D,EAAAhD,GA7+JA,GAAAd,WAAA+O,KAAA4G,IA0DA9U,cAAA,SAAAU,GACA,MAAAd,MAAA,SAAAb,GACA,GAAAkB,GAAAlB,EAAA0M,KACA/K,GAAAnC,KAAAhB,KAAAwB,EAAAkB,MA+GAU,eAAA,kBAAAC,QAqBAU,YAAAhB,gBAAAQ,UAAApB,SAmBAqV,WAAA,gBAAA1X,SAAAA,QAAAA,OAAA8E,SAAAA,QAAA9E,OAGA2X,SAAA,gBAAA1X,OAAAA,MAAAA,KAAA6E,SAAAA,QAAA7E,KAGA2X,KAAAF,YAAAC,UAAAE,SAAA,iBAGAC,SAAAF,KAAArU,OAGAwU,YAAAjT,OAAA4C,UAGArD,eAAA0T,YAAA1T,eAOAG,qBAAAuT,YAAApL,SAGArI,iBAAAwT,SAAAA,SAAAtU,gBAAAzB,GA8BAiW,cAAAlT,OAAA4C,UAOAhD,uBAAAsT,cAAArL,SAcA9H,QAAA,gBACAD,aAAA,qBAGAG,eAAA+S,SAAAA,SAAAtU,gBAAAzB,GAoBAoD,SAAA,yBACAF,QAAA,oBACAC,OAAA,6BACAE,SAAA,iBA8BAE,iBAAA,iBAgEA8D,aA2BA6O,eAAA,kBAAA1U,SAAAA,OAAAgF,SAEAO,YAAA,SAAAV,GACA,MAAA6P,iBAAA7P,EAAA6P,iBAAA7P,EAAA6P,mBAmDAlS,QAAA,qBAcAmS,cAAApT,OAAA4C,UAGAyQ,iBAAAD,cAAA7T,eAGA+T,qBAAAF,cAAAE,qBAoBAvR,YAAAf,gBAAA,WAAA,MAAA9D,eAAA8D,gBAAA,SAAAxD,GACA,MAAAuD,cAAAvD,IAAA6V,iBAAAjX,KAAAoB,EAAA,YACA8V,qBAAAlX,KAAAoB,EAAA,WA0BAqE,QAAAxE,MAAAwE,QAoBA0R,YAAA,gBAAA3Y,UAAAA,UAAAA,QAAA4Y,UAAA5Y,QAGA6Y,WAAAF,aAAA,gBAAA1Y,SAAAA,SAAAA,OAAA2Y,UAAA3Y,OAGA6Y,cAAAD,YAAAA,WAAA7Y,UAAA2Y,YAGAI,OAAAD,cAAAZ,KAAAa,WAAA1W,GAGA2W,eAAAD,OAAAA,OAAA1R,aAAAhF,GAmBAgF,SAAA2R,gBAAA1S,UAGAE,mBAAA,iBAGAC,SAAA,mBAkBAwS,UAAA,qBACAC,SAAA,iBACAC,QAAA,mBACAC,QAAA,gBACAC,SAAA,iBACAC,UAAA,oBACAC,OAAA,eACAC,UAAA,kBACAC,UAAA,kBACAC,UAAA,kBACAC,OAAA,eACAC,UAAA,kBACAC,WAAA,mBAEAC,eAAA,uBACAC,YAAA,oBACAC,WAAA,wBACAC,WAAA,wBACAC,QAAA,qBACAC,SAAA,sBACAC,SAAA,sBACAC,SAAA,sBACAC,gBAAA,6BACAC,UAAA,uBACAC,UAAA,uBAGA5T,iBACAA,gBAZA,yBAYAA,eAXA,yBAYAA,eAXA,sBAWAA,eAVA,uBAWAA,eAVA,uBAUAA,eATA,uBAUAA,eATA,8BASAA,eARA,wBASAA,eARA,yBAQA,EACAA,eAjCA,sBAiCAA,eAhCA,kBAiCAA,eApBA,wBAoBAA,eAhCA,oBAiCAA,eApBA,qBAoBAA,eAhCA,iBAiCAA,eAhCA,kBAgCAA,eA/BA,qBAgCAA,eA/BA,gBA+BAA,eA9BA,mBA+BAA,eA9BA,mBA8BAA,eA7BA,mBA8BAA,eA7BA,gBA6BAA,eA5BA,mBA6BAA,eA5BA,qBA4BA,CA4BA,IAAA6T,eAAA,gBAAAza,UAAAA,UAAAA,QAAA4Y,UAAA5Y,QAGA0a,aAAAD,eAAA,gBAAAxa,SAAAA,SAAAA,OAAA2Y,UAAA3Y,OAGA0a,gBAAAD,cAAAA,aAAA1a,UAAAya,cAGAG,YAAAD,iBAAA3C,WAAA5H,QAGAyK,SAAA,WACA,IACA,MAAAD,cAAAA,YAAAE,QAAA,QACA,MAAAna,QAIAoa,iBAAAF,UAAAA,SAAAtT,aAmBAA,aAAAwT,iBAAAlU,UAAAkU,kBAAApU,iBAGAqU,cAAA5V,OAAA4C,UAGAL,iBAAAqT,cAAArW,eAsCAsD,cAAA7C,OAAA4C,UA+BAM,WAAAJ,QAAA9C,OAAAoD,KAAApD,QAGA6V,cAAA7V,OAAA4C,UAGAO,iBAAA0S,cAAAtW,eAoMAuW,cAAAnR,QAAAD,YAAAqR,EAAAA,GAyCA9Q,OAAA,SAAA3B,EAAAxC,EAAAhD,IACA2C,YAAA6C,GAAAuB,gBAAAiR,eACAxS,EAAAnE,YAAA2B,GAAAhD,IA+DA0K,IAAAxD,WAAAE,WAmCA8Q,UAAAnX,YAAA2J,KA2BA6J,SAAA5M,gBAAAP,WAoBA+Q,UAAAtR,QAAA0N,SAAA,GAqBA6D,gBAAArX,YAAAoX,WA8CAE,QAAA1Y,KAAA,SAAAc,EAAA3B,GACA,MAAAa,MAAA,SAAA2Y,GACA,MAAA7X,GAAA9B,MAAA,KAAAG,EAAAwC,OAAAgX,QA4DApQ,QAAAL,gBAoKA4D,KAAA,SAAAZ,EAAAyB,EAAAtM,GA8DA,QAAAuY,GAAA/T,EAAA6I,GACAmL,EAAA9T,KAAA,WACA+T,EAAAjU,EAAA6I,KAIA,QAAAqL,KACA,GAAA,IAAAF,EAAAja,QAAA,IAAAoa,EACA,MAAA3Y,GAAA,KAAAsH,EAEA,MAAAkR,EAAAja,QAAAoa,EAAArM,GAAA,CACAkM,EAAArK,WAKA,QAAAyK,GAAAC,EAAApY,GACA,GAAAqY,GAAAC,EAAAF,EACAC,KACAA,EAAAC,EAAAF,OAGAC,EAAApU,KAAAjE,GAGA,QAAAuY,GAAAH,GAEAjR,UADAmR,EAAAF,OACA,SAAApY,GACAA,MAEAiY,IAGA,QAAAD,GAAAjU,EAAA6I,GACA,IAAA4L,EAAA,CAEA,GAAAC,GAAA/S,SAAAxG,KAAA,SAAAQ,EAAArB,GAKA,GAJA6Z,IACA7Z,EAAAP,QAAA,IACAO,EAAAA,EAAA,IAEAqB,EAAA,CACA,GAAAgZ,KACAlR,YAAAX,EAAA,SAAAyJ,EAAAqI,GACAD,EAAAC,GAAArI,IAEAoI,EAAA3U,GAAA1F,EACAma,GAAA,EACAF,EAAA7W,OAAAiP,OAAA,MAEAnR,EAAAG,EAAAgZ,OAEA7R,GAAA9C,GAAA1F,EACAka,EAAAxU,KAIAmU,IACA,IAAA5N,GAAA1J,YAAAgM,EAAAA,EAAA9O,OAAA,GACA8O,GAAA9O,OAAA,EACAwM,EAAAzD,EAAA4R,GAEAnO,EAAAmO,IAyBA,QAAAG,GAAAR,GACA,GAAA5Y,KAMA,OALAgI,YAAA4C,EAAA,SAAAwC,EAAA7I,GACAT,QAAAsJ,IAAA7E,YAAA6E,EAAAwL,EAAA,IAAA,GACA5Y,EAAAyE,KAAAF,KAGAvE,EA3JA,kBAAAqM,KAEAtM,EAAAsM,EACAA,EAAA,MAEAtM,EAAA6C,KAAA7C,GAAA4C,KACA,IAAA0W,GAAAhU,KAAAuF,GACA0O,EAAAD,EAAA/a,MACA,KAAAgb,EACA,MAAAvZ,GAAA,KAEAsM,KACAA,EAAAiN,EAGA,IAAAjS,MACAqR,EAAA,EACAM,GAAA,EAEAF,EAAA7W,OAAAiP,OAAA,MAEAqH,KAGAgB,KAEAC,IAEAxR,YAAA4C,EAAA,SAAAwC,EAAA7I,GACA,IAAAT,QAAAsJ,GAIA,MAFAkL,GAAA/T,GAAA6I,QACAmM,GAAA9U,KAAAF,EAIA,IAAAkV,GAAArM,EAAA9B,MAAA,EAAA8B,EAAA9O,OAAA,GACAob,EAAAD,EAAAnb,MACA,IAAA,IAAAob,EAGA,MAFApB,GAAA/T,EAAA6I,OACAmM,GAAA9U,KAAAF,EAGAiV,GAAAjV,GAAAmV,EAEA/R,UAAA8R,EAAA,SAAAE,GACA,IAAA/O,EAAA+O,GACA,KAAA,IAAAzb,OAAA,oBAAAqG,EAAA,oCAAAoV,EAAA,QAAAF,EAAArP,KAAA,MAEAuO,GAAAgB,EAAA,WAEA,MADAD,GAEApB,EAAA/T,EAAA6I,SA2EA,WAMA,IAFA,GAAAwM,GACAtS,EAAA,EACAiS,EAAAjb,QACAsb,EAAAL,EAAAhO,MACAjE,IACAK,UAAAyR,EAAAQ,GAAA,SAAAC,GACA,KAAAL,EAAAK,IACAN,EAAA9U,KAAAoV,IAKA,IAAAvS,IAAAgS,EACA,KAAA,IAAApb,OAAA,oEArFAua,KAyHA/P,UAAA,kBAyBAG,SAAA,EAAA,EAGAiR,YAAA7E,SAAAA,SAAApQ,cAAA3F,GACA0J,eAAAkR,YAAAA,YAAAhQ,aAAA5K,GAoHA6a,cAAA,kBACAC,kBAAA,iCACAC,oBAAA,kBACAC,WAAA,iBAGAC,MAAA,UAGA1Q,aAAA2Q,OAAA,uFAcAC,gBAAA,kBACAC,oBAAA,iCACAC,sBAAA,kBACAC,aAAA,iBAGAC,SAAA,oBACAC,QAAA,kDACAC,OAAA,2BACAC,WAAA,MAAAF,QAAA,IAAAC,OAAA,IACAE,YAAA,qBACAC,WAAA,kCACAC,WAAA,qCACAC,QAAA,UAGAC,SAPA,MAAAP,QAAA,IAAAC,OAAA,KAQAO,SAAA,oBACAC,UAAA,iBARA,qBAQAL,WAAAC,YAAA3Q,KAAA,KAAA,qBAAA6Q,SAAA,KACAG,MAFA,oBAEAH,SAAAE,UACAE,SAAA,OAVA,qBAUAX,QAAA,IAAAA,QAAAI,WAAAC,WAdA,qBAcA3Q,KAAA,KAAA,IAGAR,UAAAwQ,OAAAO,OAAA,MAAAA,OAAA,KAAAU,SAAAD,MAAA,KAoDAjR,OAAA,aAwCAI,QAAA,qDACAC,aAAA,IACAE,OAAA,eACAJ,eAAA,mCAsIAgR,gBAAA,kBAAAC,eAAAA,aACAC,YAAA,gBAAAvO,UAAA,kBAAAA,SAAAwO,SAcAC,MAGAA,QADAJ,gBACAC,aACAC,YACAvO,QAAAwO,SAEAhQ,QAGA,IAAAoB,gBAAAlB,KAAA+P,OAgBA7P,KAAAhH,UAAA8W,WAAA,SAAAzP,GAMA,MALAA,GAAA0P,KAAA1P,EAAA0P,KAAAhW,KAAAsG,EAAAtG,KAAAvI,KAAAyO,KAAAI,EAAAtG,KACAsG,EAAAtG,KAAAsG,EAAAtG,KAAAgW,KAAA1P,EAAA0P,KAAAve,KAAA0O,KAAAG,EAAA0P,KAEA1P,EAAA0P,KAAA1P,EAAAtG,KAAA,KACAvI,KAAAiB,QAAA,EACA4N,GAGAL,IAAAhH,UAAAgJ,MAAAhC,IAEAA,IAAAhH,UAAAgX,YAAA,SAAA3P,EAAA4P,GACAA,EAAAF,KAAA1P,EACA4P,EAAAlW,KAAAsG,EAAAtG,KACAsG,EAAAtG,KAAAsG,EAAAtG,KAAAgW,KAAAE,EAAAze,KAAA0O,KAAA+P,EACA5P,EAAAtG,KAAAkW,EACAze,KAAAiB,QAAA,GAGAuN,IAAAhH,UAAAkX,aAAA,SAAA7P,EAAA4P,GACAA,EAAAF,KAAA1P,EAAA0P,KACAE,EAAAlW,KAAAsG,EACAA,EAAA0P,KAAA1P,EAAA0P,KAAAhW,KAAAkW,EAAAze,KAAAyO,KAAAgQ,EACA5P,EAAA0P,KAAAE,EACAze,KAAAiB,QAAA,GAGAuN,IAAAhH,UAAAmI,QAAA,SAAAd,GACA7O,KAAAyO,KAAAzO,KAAA0e,aAAA1e,KAAAyO,KAAAI,GAAAF,WAAA3O,KAAA6O,IAGAL,IAAAhH,UAAAJ,KAAA,SAAAyH,GACA7O,KAAA0O,KAAA1O,KAAAwe,YAAAxe,KAAA0O,KAAAG,GAAAF,WAAA3O,KAAA6O,IAGAL,IAAAhH,UAAAqJ,MAAA,WACA,MAAA7Q,MAAAyO,MAAAzO,KAAAse,WAAAte,KAAAyO,OAGAD,IAAAhH,UAAA0G,IAAA,WACA,MAAAlO,MAAA0O,MAAA1O,KAAAse,WAAAte,KAAA0O,MA6PA,IAAAyC,cAAA5H,QAAAD,YAAA,GA6FAqV,MAAAtc,KAAA,SAAAuc,GACA,GAAAC,GAAA1T,SAAAyT,EAAA7a,YACA,OAAA1B,MAAA,SAAAb,GACA,GAAAqC,GAAA7D,KAEA8D,EAAAtC,EAAAA,EAAAP,OAAA,EACA,mBAAA6C,GACAtC,EAAA0M,MAEApK,EAAAwB,KAGA2L,OAAA4N,EAAArd,EAAA,SAAAsd,EAAA3b,EAAAW,GACAX,EAAA9B,MAAAwC,EAAAib,EAAA9a,OAAA3B,KAAA,SAAAQ,EAAAkc,GACAjb,EAAAjB,EAAAkc,QAEA,SAAAlc,EAAAmH,GACAlG,EAAAzC,MAAAwC,GAAAhB,GAAAmB,OAAAgG,UAwCAgV,QAAA3c,KAAA,SAAAb,GACA,MAAAmd,OAAAtd,MAAA,KAAAG,EAAA+S,aAwCAvQ,OAAA4F,WAAAyH,UA0BA4N,aAAA1N,SAAAF,UA4CA6N,SAAA7c,KAAA,SAAA8c,GACA,GAAA3d,IAAA,MAAAwC,OAAAmb,EACA,OAAA1c,eAAA,SAAA2c,EAAA1c,GACA,MAAAA,GAAArB,MAAArB,KAAAwB,OAsEA6d,OAAAzV,WAAA4H,cAAArP,SAAA0P,iBAwBAyN,YAAAjV,gBAAAmH,cAAArP,SAAA0P,iBAsBA0N,aAAAhW,QAAA+V,YAAA,GAiDAE,IAAA1N,YAAA,OA0QA2N,WAAAlW,QAAAkJ,YAAA,GAwFAiN,MAAA9V,WAAA4H,cAAAqB,MAAAA,QAsBA8M,WAAAtV,gBAAAmH,cAAAqB,MAAAA,QAqBA+M,YAAArW,QAAAoW,WAAA,GAwFAE,OAAAjW,WAAAwJ,SAqBA0M,YAAAzV,gBAAA+I,SAmBA2M,aAAAxW,QAAAuW,YAAA,GA6DAE,aAAA,SAAA9X,EAAAa,EAAArD,EAAAhD,GACAA,EAAAA,GAAA4C,IACA,IAAA4E,GAAAnG,YAAA2B,EACAuR,UAAA/O,EAAAa,EAAA,SAAA0K,EAAA/Q,GACAwH,EAAAuJ,EAAA,SAAA5Q,EAAAqE,GACA,MAAArE,GAAAH,EAAAG,GACAH,EAAA,MAAAwE,IAAAA,EAAAuM,IAAAA,OAEA,SAAA5Q,EAAAod,GAKA,IAAA,GAJAtd,MAEAwB,EAAAS,OAAA4C,UAAArD,eAEAvD,EAAA,EAAAA,EAAAqf,EAAAhf,OAAAL,IACA,GAAAqf,EAAArf,GAAA,CACA,GAAAsG,GAAA+Y,EAAArf,GAAAsG,IACAuM,EAAAwM,EAAArf,GAAA6S,GAEAtP,GAAAnD,KAAA2B,EAAAuE,GACAvE,EAAAuE,GAAAE,KAAAqM,GAEA9Q,EAAAuE,IAAAuM,GAKA,MAAA/Q,GAAAG,EAAAF,MAwCAud,QAAA3W,QAAAyW,aAAArF,EAAAA,GAqBAwF,cAAA5W,QAAAyW,aAAA,GA6BAI,IAAAtO,YAAA,OAmFAuO,UAAA9W,QAAAgK,eAAAoH,EAAAA,GAqBA2F,gBAAA/W,QAAAgK,eAAA,GAwGAgN,QAGAA,UADApC,YACAvO,QAAAwO,SACAH,gBACAC,aAEA9P,QAGA,IAAAgQ,UAAA9P,KAAAiS,UAqNAC,QAAA,SAAAzR,EAAAC,GACA,GAAAqB,GAAAtM,YAAAgL,EACA,OAAAD,OAAA,SAAA2R,EAAA3c,GACAuM,EAAAoQ,EAAA,GAAA3c,IACAkL,EAAA,IA0BA0R,cAAA,SAAA3R,EAAAC,GAEA,GAAAK,GAAAmR,QAAAzR,EAAAC,EA4CA,OAzCAK,GAAAjI,KAAA,SAAA+H,EAAAwR,EAAAje,GAEA,GADA,MAAAA,IAAAA,EAAA4C,MACA,kBAAA5C,GACA,KAAA,IAAA7B,OAAA,mCAMA,IAJAwO,EAAAC,SAAA,EACA7I,QAAA0I,KACAA,GAAAA,IAEA,IAAAA,EAAAlO,OAEA,MAAAuO,gBAAA,WACAH,EAAAI,SAIAkR,GAAAA,GAAA,CAEA,KADA,GAAAC,GAAAvR,EAAAK,OAAAjB,KACAmS,GAAAD,GAAAC,EAAAD,UACAC,EAAAA,EAAArY,IAGA,KAAA,GAAA3H,GAAA,EAAAG,EAAAoO,EAAAlO,OAAAL,EAAAG,EAAAH,IAAA,CACA,GAAA0H,IACA6G,KAAAA,EAAAvO,GACA+f,SAAAA,EACAje,SAAAA,EAGAke,GACAvR,EAAAK,OAAAgP,aAAAkC,EAAAtY,GAEA+G,EAAAK,OAAAtI,KAAAkB,GAGAkH,eAAAH,EAAAO,gBAIAP,GAAAM,QAEAN,GAgDApB,MAAAhM,MAAAuF,UAAAyG,MAgIA4S,OAAAjX,WAAA+K,UAqGAmM,YAAAzW,gBAAAsK,UAmBAoM,aAAAxX,QAAAuX,YAAA,GA8LAE,UAAA,SAAAjM,EAAAhF,GACAA,IACAA,EAAAgF,EACAA,EAAA,KAEA,IAAAE,GAAAlR,YAAAgM,EACA,OAAAtN,eAAA,SAAAjB,EAAAkB,GACA,QAAA+K,GAAA3J,GACAmR,EAAA5T,MAAA,KAAAG,EAAAwC,OAAAF,IAGAiR,EAAAD,MAAAC,EAAAtH,EAAA/K,GAAAoS,MAAArH,EAAA/K,MAsGAue,KAAArX,WAAA4H,cAAA0P,QAAA/e,WAuBAgf,UAAA9W,gBAAAmH,cAAA0P,QAAA/e,WAsBAif,WAAA7X,QAAA4X,UAAA,GA8IArK,WAAAnG,KAAA0Q,KACAxK,YAAAlG,KAAA4G,IA8EAnC,MAAA7L,QAAAwN,UAAA4D,EAAAA,GAgBA2G,YAAA/X,QAAAwN,UAAA,GAkNAwK,UAAA,SAAAhU,EAAA7K,GAMA,QAAA8e,GAAAhgB,GACA,GAAAigB,IAAAlU,EAAAtM,OACA,MAAAyB,GAAArB,MAAA,MAAA,MAAA2C,OAAAxC,GAGA,IAAAoa,GAAA/S,SAAAxG,KAAA,SAAAQ,EAAArB,GACA,GAAAqB,EACA,MAAAH,GAAArB,MAAA,MAAAwB,GAAAmB,OAAAxC,GAEAggB,GAAAhgB,KAGAA,GAAA4F,KAAAwU,GAEA7X,YAAAwJ,EAAAkU,MACApgB,MAAA,KAAAG,GAnBA,GADAkB,EAAA6C,KAAA7C,GAAA4C,OACAmB,QAAA8G,GAAA,MAAA7K,GAAA,GAAA7B,OAAA,6DACA,KAAA0M,EAAAtM,OAAA,MAAAyB,IACA,IAAA+e,GAAA,CAoBAD,QAmEAzf,OACA6Y,UAAAA,UACAE,gBAAAA,gBACAzZ,MAAA0Z,QACAvY,SAAAA,SACA2L,KAAAA,KACAb,WAAAA,WACA0D,MAAAA,MACAgO,QAAAA,QACAhb,OAAAA,OACAib,aAAAA,aACAC,SAAAA,SACAG,OAAAA,OACAC,YAAAA,YACAC,aAAAA,aACAC,IAAAA,IACAxN,SAAAA,SACAK,QAAAA,QACAD,SAAAA,SACAE,OAAAA,OACAoP,KAAAlP,UACAA,UAAAC,YACA5I,OAAAA,OACAP,YAAAA,YACA6H,aAAAA,aACAsO,WAAAA,WACA/M,YAAAA,YACAgN,MAAAA,MACAC,WAAAA,WACAC,YAAAA,YACAC,OAAAA,OACAC,YAAAA,YACAC,aAAAA,aACA1M,QAAAA,QACA6M,QAAAA,QACAF,aAAAA,aACAG,cAAAA,cACAC,IAAAA,IACAhT,IAAAA,IACA6J,SAAAA,SACA4D,UAAAA,UACAwF,UAAAA,UACA9M,eAAAA,eACA+M,gBAAAA,gBACA3M,QAAAA,QACAyK,SAAAA,SACAuD,SAAAzN,cACAA,cAAAC,gBACAuM,cAAAA,cACA5R,MAAA0R,QACApM,KAAAA,KACAnD,OAAAA,OACAqD,YAAAA,YACAE,QAAAA,QACAI,WAAAA,WACAiM,OAAAA,OACAC,YAAAA,YACAC,aAAAA,aACAjM,MAAAA,MACAkM,UAAAA,UACAY,IAAAjD,MACAhJ,OAAAA,OACAuI,aAAA1O,eACAyR,KAAAA,KACAE,UAAAA,UACAC,WAAAA,WACAxL,OAAAA,OACAK,QAAAA,QACAb,MAAAA,MACAyM,WAAA9K,UACAuK,YAAAA,YACA3f,UAAAA,UACAyV,UAAAA,UACAE,MAAAA,MACAiK,UAAAA,UACAlK,OAAAA,OAGAyK,IAAApC,MACAqC,IAAAd,KACAe,QAAAxP,UACAyP,cAAAxC,WACAyC,aAAAzP,YACA0P,UAAAtY,OACAuY,gBAAAjR,aACAkR,eAAA/Y,YACAgZ,OAAArR,OACAsR,MAAAtR,OACAuR,MAAAlO,YACAmO,OAAA5C,OACA6C,YAAA5C,YACA6C,aAAA5C,aACA6C,SAAApgB,SAGAhD,SAAA,QAAAuC,MACAvC,QAAAob,UAAAA,UACApb,QAAAsb,gBAAAA,gBACAtb,QAAA6B,MAAA0Z,QACAvb,QAAAgD,SAAAA,SACAhD,QAAA2O,KAAAA,KACA3O,QAAA8N,WAAAA,WACA9N,QAAAwR,MAAAA,MACAxR,QAAAwf,QAAAA,QACAxf,QAAAwE,OAAAA,OACAxE,QAAAyf,aAAAA,aACAzf,QAAA0f,SAAAA,SACA1f,QAAA6f,OAAAA,OACA7f,QAAA8f,YAAAA,YACA9f,QAAA+f,aAAAA,aACA/f,QAAAggB,IAAAA,IACAhgB,QAAAwS,SAAAA,SACAxS,QAAA6S,QAAAA,QACA7S,QAAA4S,SAAAA,SACA5S,QAAA8S,OAAAA,OACA9S,QAAAkiB,KAAAlP,UACAhT,QAAAgT,UAAAC,YACAjT,QAAAqK,OAAAA,OACArK,QAAA8J,YAAAA,YACA9J,QAAA2R,aAAAA,aACA3R,QAAAigB,WAAAA,WACAjgB,QAAAkT,YAAAA,YACAlT,QAAAkgB,MAAAA,MACAlgB,QAAAmgB,WAAAA,WACAngB,QAAAogB,YAAAA,YACApgB,QAAAqgB,OAAAA,OACArgB,QAAAsgB,YAAAA,YACAtgB,QAAAugB,aAAAA,aACAvgB,QAAA6T,QAAAA,QACA7T,QAAA0gB,QAAAA,QACA1gB,QAAAwgB,aAAAA,aACAxgB,QAAA2gB,cAAAA,cACA3gB,QAAA4gB,IAAAA,IACA5gB,QAAA4N,IAAAA,IACA5N,QAAAyX,SAAAA,SACAzX,QAAAqb,UAAAA,UACArb,QAAA6gB,UAAAA,UACA7gB,QAAA+T,eAAAA,eACA/T,QAAA8gB,gBAAAA,gBACA9gB,QAAAmU,QAAAA,QACAnU,QAAA4e,SAAAA,SACA5e,QAAAmiB,SAAAzN,cACA1U,QAAA0U,cAAAC,gBACA3U,QAAAkhB,cAAAA,cACAlhB,QAAAsP,MAAA0R,QACAhhB,QAAA4U,KAAAA,KACA5U,QAAAyR,OAAAA,OACAzR,QAAA8U,YAAAA,YACA9U,QAAAgV,QAAAA,QACAhV,QAAAoV,WAAAA,WACApV,QAAAqhB,OAAAA,OACArhB,QAAAshB,YAAAA,YACAthB,QAAAuhB,aAAAA,aACAvhB,QAAAsV,MAAAA,MACAtV,QAAAwhB,UAAAA,UACAxhB,QAAAoiB,IAAAjD,MACAnf,QAAAmW,OAAAA,OACAnW,QAAA0e,aAAA1O,eACAhQ,QAAAyhB,KAAAA,KACAzhB,QAAA2hB,UAAAA,UACA3hB,QAAA4hB,WAAAA,WACA5hB,QAAAoW,OAAAA,OACApW,QAAAyW,QAAAA,QACAzW,QAAA4V,MAAAA,MACA5V,QAAAqiB,WAAA9K,UACAvX,QAAA8hB,YAAAA,YACA9hB,QAAAmC,UAAAA,UACAnC,QAAA4X,UAAAA;4BACA5X,QAAA8X,MAAAA,MACA9X,QAAA+hB,UAAAA,UACA/hB,QAAA6X,OAAAA,OACA7X,QAAAsiB,IAAApC,MACAlgB,QAAAqjB,SAAAlD,WACAngB,QAAAsjB,UAAAlD,YACApgB,QAAAuiB,IAAAd,KACAzhB,QAAAujB,SAAA5B,UACA3hB,QAAAwjB,UAAA5B,WACA5hB,QAAAyjB,KAAA5D,OACA7f,QAAA0jB,UAAA5D,YACA9f,QAAA2jB,WAAA5D,aACA/f,QAAAwiB,QAAAxP,UACAhT,QAAAyiB,cAAAxC,WACAjgB,QAAA0iB,aAAAzP,YACAjT,QAAA2iB,UAAAtY,OACArK,QAAA4iB,gBAAAjR,aACA3R,QAAA6iB,eAAA/Y,YACA9J,QAAA8iB,OAAArR,OACAzR,QAAA+iB,MAAAtR,OACAzR,QAAAgjB,MAAAlO,YACA9U,QAAAijB,OAAA5C,OACArgB,QAAAkjB,YAAA5C,YACAtgB,QAAAmjB,aAAA5C,aACAvgB,QAAAojB,SAAApgB,SAEAoC,OAAAwe,eAAA5jB,QAAA,cAAA4C,OAAA,8KCt1KA,QAAAihB,KACA,KAAA,IAAAxiB,OAAA,mCAEA,QAAAyiB,KACA,KAAA,IAAAziB,OAAA,qCAsBA,QAAA0iB,GAAAC,GACA,GAAAC,IAAApV,WAEA,MAAAA,YAAAmV,EAAA,EAGA,KAAAC,IAAAJ,IAAAI,IAAApV,WAEA,MADAoV,GAAApV,WACAA,WAAAmV,EAAA,EAEA,KAEA,MAAAC,GAAAD,EAAA,GACA,MAAArjB,GACA,IAEA,MAAAsjB,GAAAziB,KAAA,KAAAwiB,EAAA,GACA,MAAArjB,GAEA,MAAAsjB,GAAAziB,KAAAhB,KAAAwjB,EAAA,KAMA,QAAAE,GAAAC,GACA,GAAAC,IAAArN,aAEA,MAAAA,cAAAoN,EAGA,KAAAC,IAAAN,IAAAM,IAAArN,aAEA,MADAqN,GAAArN,aACAA,aAAAoN,EAEA,KAEA,MAAAC,GAAAD,GACA,MAAAxjB,GACA,IAEA,MAAAyjB,GAAA5iB,KAAA,KAAA2iB,GACA,MAAAxjB,GAGA,MAAAyjB,GAAA5iB,KAAAhB,KAAA2jB,KAYA,QAAAE,KACAC,GAAAC,IAGAD,GAAA,EACAC,EAAA9iB,OACA6N,EAAAiV,EAAA/f,OAAA8K,GAEAkV,GAAA,EAEAlV,EAAA7N,QACAgjB,KAIA,QAAAA,KACA,IAAAH,EAAA,CAGA,GAAA7N,GAAAsN,EAAAM,EACAC,IAAA,CAGA,KADA,GAAA3b,GAAA2G,EAAA7N,OACAkH,GAAA,CAGA,IAFA4b,EAAAjV,EACAA,OACAkV,EAAA7b,GACA4b,GACAA,EAAAC,GAAAE,KAGAF,IAAA,EACA7b,EAAA2G,EAAA7N,OAEA8iB,EAAA,KACAD,GAAA,EACAJ,EAAAzN,IAiBA,QAAAkO,GAAAX,EAAAxhB,GACAhC,KAAAwjB,IAAAA,EACAxjB,KAAAgC,MAAAA,EAYA,QAAAsD,MAhKA,GAOAme,GACAG,EARAhU,EAAAnQ,EAAAD,YAgBA,WACA,IAEAikB,EADA,kBAAApV,YACAA,WAEAgV,EAEA,MAAAljB,GACAsjB,EAAAJ,EAEA,IAEAO,EADA,kBAAArN,cACAA,aAEA+M,EAEA,MAAAnjB,GACAyjB,EAAAN,KAuDA,IAEAS,GAFAjV,KACAgV,GAAA,EAEAE,GAAA,CAyCApU,GAAAwO,SAAA,SAAAoF,GACA,GAAAhiB,GAAA,GAAAS,OAAAH,UAAAb,OAAA,EACA,IAAAa,UAAAb,OAAA,EACA,IAAA,GAAAL,GAAA,EAAAA,EAAAkB,UAAAb,OAAAL,IACAY,EAAAZ,EAAA,GAAAkB,UAAAlB,EAGAkO,GAAA1H,KAAA,GAAA+c,GAAAX,EAAAhiB,IACA,IAAAsN,EAAA7N,QAAA6iB,GACAP,EAAAU,IASAE,EAAA3c,UAAA0c,IAAA,WACAlkB,KAAAwjB,IAAAniB,MAAA,KAAArB,KAAAgC,QAEA4N,EAAAwU,MAAA,UACAxU,EAAAyU,SAAA,EACAzU,EAAA0U,OACA1U,EAAA2U,QACA3U,EAAA4U,QAAA,GACA5U,EAAA6U,YAIA7U,EAAA8U,GAAApf,EACAsK,EAAA0L,YAAAhW,EACAsK,EAAArK,KAAAD,EACAsK,EAAA+U,IAAArf,EACAsK,EAAAgV,eAAAtf,EACAsK,EAAAiV,mBAAAvf,EACAsK,EAAAkV,KAAAxf,EAEAsK,EAAA0K,QAAA,SAAAxM,GACA,KAAA,IAAAjN,OAAA,qCAGA+O,EAAAmV,IAAA,WAAA,MAAA,KACAnV,EAAAoV,MAAA,SAAAxF,GACA,KAAA,IAAA3e,OAAA,mCAEA+O,EAAAqV,MAAA,WAAA,MAAA,wJCnLCtkB,EAAA,eACDA,EAAA,aACAA,EAAA,kBACAA,EAAA,aACAA,EAAA,eAEAukB,QAAQzlB,OAAO,eACX,eACA,aACA,iBACA,aACA,YACA,WACA,YACA,UACA,WACA,gBACA,iBAGJ0lB,EAAAxkB,EAAA,gBACAwkB,EAAAxkB,EAAA,cACAwkB,EAAAxkB,EAAA,mBACAwkB,EAAAxkB,EAAA,4ICbYykB,GAAmBC,gBAEZC,IAAE,sBAAW,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,MAChBC,IACF9X,KAAA0X,EAAA1X,KAEE+X,IAAAL,EAAaK,IACbhY,OAAM4X,GAENK,GACFhY,KAAA4X,EAAA5X,KAEN+X,IAAAH,EAAWG,IACXhY,OAAW8X,EAIlBN,GAAA7lB,EAAAumB,UAAAH,EAGDP,EAAA7lB,EAAAwmB,cAAgDF,YAI5CG,GAA4BC,EAAAC,EAAgBd,GAE5C,UAOA,SAAAe,KAEID,EAAME,QAAUC,eAKZC,GAAiB1Y,MAEjBwX,EAAa7lB,EAAMumB,WAAYV,EAAQ7lB,EAAAwmB,cAAA,CAC1C,GAAAQ,GAAArc,EAAAsc,UAAApB,EAAA7lB,EAAAwmB,cAAKQ,GAAE3Y,OAAA1D,EAAAuc,OAAAF,EAAA3Y,OAAAA,GACJqY,EAAQtiB,GAAA4iB,EAAQ1Y,KAAO0Y,EAAA3Y,YAGlCsY,GAAAE,QAAAC,OAhBG,MAFAJ,GAAAE,OAAAA,IACIG,gBAAsBA,EACzBL,EAuBL,QAAOS,GAAAC,KACKC,UAAA,SAAaZ,4BAjEdA,EAAmBa,SAAS,YAAA,UAAA,cAC5BH,EAAYG,SAAW,YAGlCliB,OAAAwe,eAAA5jB,EAAA,cAAkE4C,OAAA,MAC9D2jB,SAAW,WAEXC,aAAe,gECPRe,GAAA,SAAUpmB,EAAWlB,EAAWD,GAE3C,qBAWMwnB,GAAA3B,EAAA4B,EAAAC,GAEF,aAGQ5B,IAAW,oBAAW,SAASC,EAAAC,EAAAC,EAAAC,EAAAC,GAErCN,EAAA7lB,EAAA2nB,aAAA,MAMM7B,IAAW,sBAAc,SAAMC,EAAAC,EAAAC,EAAAC,EAAAC,GAE/BN,EAAW7lB,EAAA2nB,aAAA,IAEf9B,EACFC,IAAA,oBAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAzV,GAELmV,EAAA7lB,EAAA2nB,aAAA,EAEMF,EAAA/W,MAAA,kCAAAsV,EAAA1X,MACFmZ,EAAO/W,MAAAA,OA7BG4W,SAAA,aAAA,OAAA,iBAEX1D,eAAe5jB,EAAA,cACX4C,OAAC,MACG+kB,WAAW,mFCXvB,SAAQhC,GAAOiC,GAEf,IAAA,GAAAC,KAAAD,GAAA5nB,EAAyB2E,eAAAkjB,KAAA7nB,EAAA6nB,GAAAD,EAAAC,IAGzBziB,OAAAwe,eAAA5jB,EAAA,cAAgC4C,OAAA,IAChC8iB,QAAAzlB,OAAA,cAAA,gFCJW0lB,EAAAxkB,EAAA,sBACA2mB,kBAAA,EAAAC,kBAAuB,IAAAC,GAAA,SAAqB7mB,EAAAlB,EAAAD,GAEvD,oBAMI4jB,eAAA5jB,EACI,cACA4C,OACA,MAGAqlB,gBAAgB,cAChBC,qBAAiB,2BACF,mBACVC,GAAYC,EAAAzlB,EAAAkjB,EAAA4B,GAEjBjnB,KAAK6nB,YAAaD,EACrB5nB,KAAA8nB,UAAA3lB,EAEOnC,KAAA+nB,WAAA1C,EACJrlB,KAAIgoB,KAAKf,OACLW,mBAGRD,GAAAngB,UAAWogB,WAAA,gBAAXC,cACI7nB,KAAA+nB,WAAYvoB,EAAUioB,iBAAAznB,KAAA8nB,kCAGNH,EAAUngB,UAAA,gBAC1B,WACA,MAAKxH,MAAA8nB,eAGL,SAAI1lB,GACJpC,KAAK8nB,UAAW1lB,EACnBpC,KAAA4nB,qFATA5nB,MAAAgoB,KAAAC,MAAA,uBAAAC,KAAAC,UAAAhmB,KAUJimB,YAAA,EAEDC,cAAA,IACYV,OAE4B,WAEb,QAACW,KAExBtoB,KAAA6nB,aAAW,OAAXC,UAAA,UACIS,SAAY,kCAGMD,EAAc9gB,UAAA,kBAChC,WACH,MAAAxH,MAAA6nB,6BAJA7nB,KAAA6nB,cAAAzlB,eAMD,gBACW,0BAGSkmB,EAAU9gB,UAAA,gBAC1B,WACH,MAAAxH,MAAA8nB,2BAJA9nB,KAAA8nB,UAAA1lB,GAUGgmB,YAAW,EAEXC,cAAS,MAGG7gB,UAASghB,MAAA,aAAA,OAAA,SAAAnD,EAAA4B,GACxB,UAIE,OAFN,OAADjnB,KAAAuoB,WAACvoB,KAAAuoB,SAAA,GAAAZ,GAAA3nB,KAAA6nB,YAAA7nB,KAAA8nB,UAAAzC,EAAA4B,IAEMjnB,KAAAuoB,WAEFD,kCCjFQG,SAAA,cAAiBH,QACjBI,GAAA,SAAA/nB,EAAkBlB,EAAGD,GACrB,YAEboF,QAAIwe,eAAgB5jB,EAAS,cAAA4C,OAAA,IAE7B5C,EAAAmpB,eAAA,aAQIC,mBACI,qBAJIC,mBAAoB,yBACpBloB,EAAA,WAQC,mBACAmoB,GAAWlB,EAAQmB,EAAA1D,EAAA4B,GACxBjnB,KAAKyb,aACLzb,KAAKgpB,aAAY,EAEjBhpB,KAAK6nB,YAAaD,EACrB5nB,KAAAipB,SAAAF,EAEO/oB,KAAA+nB,WAAA1C,EACJrlB,KAAKgoB,KAAMf,OACPW,sBAGKpgB,UAAU0hB,gBAAiB,SAAO3mB,EAAA4mB,OACvC5mB,OAGI,IAAA1B,OAAS,wCAEhBb,MAAAyb,UAAAlZ,YAAAN,OAAKb,EAAEsgB,KAAA1hB,KAAAyb,UAAAlZ,GAAA,SAAA6mB,EAAA1mB,GACJ0mB,EAAA1mB,IACHymB,GAGLA,OAGY3hB,UAAa6hB,oBAAU,SAAA3mB,MAC3B4mB,GAACtpB,UAACkpB,gBAAM,OAAA,SAAAhZ,EAAAvN,GAGJuN,GAKXoZ,EAAAtB,KAAA9X,MAAAA,GAEOxN,EAAAwN,IANIxN,EAAS,KAAMC,QASf6E,UAAa+hB,qBAAU,SAAA7mB,MAC3B4mB,GAACtpB,UAACkpB,gBAAM,QAAA,SAAAhZ,EAAAvN,GACJuN,GAKXoZ,EAAAtB,KAAA9X,MAAAA,GAEOxN,EAAAwN,IANIxN,EAAS,KAAMC,MAWnBmmB,EAAAthB,UAAAogB,WAAR,WACQ5nB,KAAC6nB,cACD7nB,KAAC+nB,WAAWvoB,EAAMmpB,gBAAA3oB,KAAoBipB,WAE9CH,EAACthB,UAAA9F,MAAA,SAAAqnB,GAEO/oB,KAAA4nB,aACJ5nB,KAAI+nB,WAAUyB,MAAQhqB,EAAQopB,mBAACG,GAE/B/oB,KAAKgoB,KAAAC,MAAW,kBAAKc,MAEhBvhB,UAAgBiiB,KAAC,WAEtB,GAAIC,GAAY1pB,KAAAipB,QACnBjpB,MAAAipB,SAAA,KAEOjpB,KAAA4nB,aACJ5nB,KAAI+nB,WAAYyB,MAAAhqB,EAAcqpB,mBAAmBa,QAC7C1B,KAAKC,MAAA,kBAAqByB,MAGzBliB,UAAgB8T,YAAc,SAAC/Y,EAAA6mB,OACvC,KAAAppB,KAAAyb,UAAAlZ,KAEOvC,KAAAyb,UAAAlZ,YAEAkZ,UAAIlZ,GAAY6E,KAAKgiB,MAEd5hB,UAAUod,eAAiB,SAAEriB,EAAA6mB,qBAC5B7mB,YAAuBN,WAE1B,MADSjC,KAAAyb,UAAAlZ,GACT3B,EAAA,EAAAuH,EAAAsT,EAAAxa,OAAAL,EAAAuH,EAAAvH,IACJ,GAAA6a,EAAA7a,KAAAwoB,EAAA,CACJ3N,EAAAxL,OAAArP,EAAA,EACJ,WAOQ4G,UAAYmiB,gBAAmB,SAAAP,GACvCppB,KAAAsb,YAAA,OAAA8N,MAGQ5hB,UAAeoiB,iBAAkB,SAAAR,GACzCppB,KAAAsb,YAAA,QAAA8N,MAGQ5hB,UAAeqiB,mBAAmB,SAAAT,GAC1CppB,KAAA4kB,eAAA,OAAAwE,MAED5hB,UAAAsiB,oBAAA,SAAAV,QACIxE,eAAY,QAASwE,gEACxB,MAAAppB,MAAAipB,UAGGb,YAAY,EACfC,cAAA,MAED7gB,UAaCuiB,SAAA,WAZG,MAAoB,OAAhB/pB,KAAOipB,YAGNzhB,UAAWwiB,KAAQ,SAAAjB,GAExB,GAAIO,GAACtpB,QACU,MAAX+oB,OACI,IAAKloB,OAAM,+BACdooB,SAAAF,OAACM,oBAAM,SAAAnZ,EAAAvN,GACJuN,EAKLoZ,EAAAG,OAJEH,EAAA5nB,MAAAqnB,QAK+BvhB,UAAAyiB,MAAA,WAEpC,GAAIX,GAACtpB,IACU,OAAXA,KAAK+oB,SAEZ/oB,KAAAupB,qBAAA,SAAArZ,EAAAvN,GACLuN,GAACoZ,EAAAG,UAGWX,OAEQ,WAEO,QAACoB,KAExBlqB,KAAA6nB,aAAW,OAAXoB,SAAA,UACIV,SAAY,kCAGM2B,EAAc1iB,UAAA,kBAChC,WACH,MAAAxH,MAAA6nB,6BAJA7nB,KAAA6nB,cAAAzlB,eAMD,gBACW,0BAGQ8nB,EAAU1iB,UAAA,eACzB,WACH,MAAAxH,MAAAipB,0BAJAjpB,KAAAipB,SAAA7mB,GAUGgmB,YAAW,EAEXC,cAAS,MAGG7gB,UAASghB,MAAA,aAAA,OAAA,SAAAnD,EAAA4B,GACxB,UAGE,OAFN,OAADjnB,KAAAuoB,WAACvoB,KAAAuoB,SAAA,GAAAO,GAAA9oB,KAAA6nB,YAAA7nB,KAAAipB,SAAA5D,EAAA4B,IAEMjnB,KAAAuoB,WAEF2B,sGCvML,SAAQ/E,GAAOiC,GAEf,IAAA,GAAAC,KAAAD,GAAA5nB,EAA2B2E,eAAAkjB,KAAA7nB,EAAA6nB,GAAAD,EAAAC,IAK3BziB,OAAAwe,eAAA5jB,EAAA,cAAkC4C,OAAA,IAGlC8iB,QAAAzlB,OAAA,wFCVA0lB,EAAAxkB,EAAA,uBAEAwpB,oBAAA,EAAAC,mBAAA,IAAAC,IAAA,SAAA1pB,EAAAlB,EAAAD,sCAC6BA,EAAK,cAAA4C,OAAA,UACHzB,EAAA,wBACnB,mBACA2pB,GAA2BC,GAC3BvqB,KAAAwqB,OAAS,KAGbxqB,KAAKyqB,IAAM,KACdzqB,KAAA0qB,WAAA,KAED1qB,KAAA2qB,OAAA,GAAWC,GAAAC,sBAAXC,UAAA,OACIN,OAAOD,mEACV,MAAAvqB,MAAAwqB,oBAED,gBACW,2DACV,MAAAxqB,MAAAyqB,iBAED,gBACW,kEACV,MAAAzqB,MAAA0qB,wBAED,gBACW,iEACV,MAAA1qB,MAAA8qB,uBAED,gBACW,8DACV,MAAA9qB,MAAA2qB,oBAED,gBACW,qEACV,MAAA3qB,MAAA2qB,OAAA7nB,SAGGslB,YAAW,EACXC,cAAK,MAEA7gB,UAAYujB,MAAG,WACvB/qB,KAAAyqB,IAAA,KAEMzqB,KAAA0qB,WAAA,KACH1qB,KAAA8qB,UAAe,EAClB9qB,KAAA2qB,OAAAI,WAGWvjB,UAAKwjB,KAAY,WAC5B,MAAA,OAAAhrB,KAAAyqB,OAGUjjB,UAAQyjB,OAAO,WACzB,OAAAjrB,KAAA2qB,OAAAna,WAIWhJ,UAAQ0jB,QAAK,SAAAC,SAACnrB,MAAOyqB,KAAKU,KAG7B3jB,UAAa4jB,MAAA,SAAaC,GAC/B,MAAY,OAARrrB,KAACyqB,IAEM,MACdzqB,KAAAyqB,KAAA,GAAAa,OAAAC,UAAA9e,WAEMzM,KAAA0qB,WAAAW,GAAP,aACIrrB,KAAK2qB,OAAAI,QACR/qB,KAAAyqB,QAGWjjB,UAAQgkB,OAAA,SAAAC,GAChBzrB,KAAK8qB,UAAYna,KAAG4G,IAAAkU,EAAA,MAGjBnB,EAAA9iB,UAAAkkB,MAAP,WACI1rB,KAAKyqB,IAAM,KACXzqB,KAAK2qB,OAAMI,SAEnBT,EAAA9iB,UAACkE,IAAA,SAAAwE,GAAAlQ,KAAA2qB,OAAAgB,OAAAzb,GA9EYlQ,KAAAyqB,IAAA,UCFbjrB,GAAA8qB,YAAAA,yBAOI,KAAAsB,IAAmB,SAAWjrB,EAAAlB,EAAAD,sCAEjBA,EAAc,cAAA4C,OAAA,OAC3ByoB,GAAC,WAEM,QAAAA,GAAA3a,GACS,MAARA,GACAlQ,KAAC2rB,OAAUzb,YAEF1I,UAAKujB,MAAA,WAClB/qB,KAAKc,KAAA,KACRd,KAAA8C,QAAA,KAEM9C,KAAA6rB,QAAA,KACH7rB,KAAA8rB,MAAY,KACf9rB,KAAA+rB,YAAA,QAGgBvkB,UAAAgJ,MAAA,WAEb,MAAIxQ,MAAK8C,QAAS,QAGR0E,UAAUmkB,OAAA,SAAAzb,QAChB6a,QACH,MAAA7a,IAIGA,EAAIpN,eAEAA,QAAKoN,EAAUpN,SAEnBoN,EAACf,OAEGe,EAAMf,KAAKrO,OACXd,KAAK8C,QAAU9C,KAAK8C,SAAW,SAAWoN,EAAAf,KAAQrO,KACrDd,KAAAc,KAAAd,KAAAc,MAAAoP,EAAAf,KAAArO,MAGGoP,EAACf,KAAUrM,UAEX9C,KAAC8C,QAAc9C,KAAK8C,SAAMoN,EAAAf,KAAArM,SAE9B9C,KAAK8C,QAAU9C,KAAK8C,SAAMoN,EAAQf,KACrCnP,KAAA6rB,QAAA7rB,KAAA6rB,SAAA3b,EAAAf,KAGGnP,KAAK8rB,MAAC5b,EAAaf,KAAA2c,MACnB9rB,KAAK+rB,YAAc7b,EAACf,KAAO4c,YAC9B/rB,KAAA6rB,QAAA3b,EAAAf,KAAA0c,SAEG3b,EAAK8b,aACLhsB,KAAK8C,QAAO9C,KAAK8C,SAAcoN,EAAM8b,YAGrC9b,EAAC+b,SACDjsB,KAAC8C,QAAc9C,KAAC8C,SAAW,SAAMoN,EAAA+b,OACxCjsB,KAAAc,KAAAd,KAAAc,MAAAoP,EAAA+b,QACJjsB,KAAA8C,QAAA9C,KAAA8C,SAAAoN,EAlEYlQ,KAAA6rB,QAAA7rB,KAAA6rB,SAAA3b,QCAb1Q,GAAAqrB,iBAAAA,OAGAqB,IAAA,SAAAvrB,EAAAlB,EAAAD,sCACYA,EAA4C,cAAC4C,OAAA,OAE/B+pB,GAACxrB,EAAA,iBAEhByrB,EAAA,mBACCA,KAEJpsB,KAAIqsB,0BAGG7kB,UAAYqM,OAAA,SAAA0W,GACtB,GAAA+B,GAAA,GAAAH,GAAA7B,YAAAC,EAKG,OAHG,OAAAA,IACCvqB,KAAAqsB,cAAgC9B,GAAQ+B,GAExCA,KAES9kB,UAAS+kB,IAAA,SAAAhC,SACK,MAAdA,EAAoBvqB,KAAGqsB,cAAY9B,GAAA,IAOjD,OANE,OAAA+B,IAEDA,EAAkB,GAACH,GAAA7B,YAAAC,GACtB,MAAAA,IACLvqB,KAAAqsB,cAAC9B,GAAA+B,IAEMA,GAEFF,sCC9BLI,QAAA,iBAAAJ,qBACe,KAAAK,IAAA,SAAA9rB,EAAAlB,EAAAD,wBAMPktB,GAA6BC,oBAEzBA,EAAcjZ,IAAA,0BACd6Y,IAAW,wBAAY,WAExBK,gBAAA,MAEHC,SAAa,cACTC,WAAY,gBACZC,QAAA,aACAC,OAAS,gBAEVJ,gBAAA,MACNC,SAAA,oBAEJC,WAAA,oBAEMC,QAAA,iBACKC,OAAA,sBArB+BlG,SAAA,oBAEpC1D,eAAe5jB,EAAC,cAAA4C,OAAA,wECRvB,YAEA,SAAA+iB,GAAAiC,GACA,IAAA,GAAAC,KAAAD,GAAA5nB,EAA4B2E,eAAAkjB,KAAA7nB,EAAA6nB,GAAAD,EAAAC,IAE5BziB,OAAAwe,eAAA5jB,EAAA,cAA8B4C,OAAA,IAE9B8iB,QAAAzlB,OAAA,qBACAkB,EAAA,6FCNAwkB,EAAAxkB,EAAA,yBACIA,EAAW,oCAEJ,GAAAssB,qBAAA,GAAAC,uBAAA,GAAAC,uBAAA,KAAAC,IAAA,SAAAzsB,EAAAlB,EAAAD,wBAKF6tB,GAAAC,8BAGO,YAEPC,KAAA,gBACHC,KAAA,QAGNC,KAAA,SAAAlD,EAAAmD,EAAgCC,GAC5B,GAAWzmB,GAAAqjB,EAAAgD,MAAAhD,EAAAiD,KAEJprB,EAAAkrB,EAAAM,UAAA1mB,EACHwmB,GAAUG,KAAIzrB,aAIb0rB,GAAAR,8BAGO,YAEPC,KAAA,oBACHC,KAAA,QAGCC,KAAA,SAAAlD,EAAAmD,EAAAC,GACK,GAAAzmB,GAAAqjB,EAAegD,MAAAhD,EAAAiD,KACZprB,EAAAkrB,EAAgBM,UAAA1mB,EAC1BwmB,GAAUK,KAAA3rB,OAhCA0kB,SAAA,kBACGA,SAAe,sCACftnB,EAAM,cAAA4C,OAAA,ICPxB8iB,QACIzlB,OAAA,gBAEAuuB,UAAO,eAAqBX,aACjB,mBAAaS,QACvBG,IAAA,SAAAttB,EAAAlB,EAAAD,GACL,wBAM2C8tB,GAEvC,iBACI,UAAOpmB,GACV,MAAAomB,GAAAM,UAAA1mB,IAAAA,WAIAgnB,GAAsBvB,sHAZ3BwB,EAAArH,SAAA,kBACeA,SAAA,oBAEX1D,eAAgB5jB,EAAsB,cAAc4C,OAAe,8FCbvE,SAAAgsB,GAAAd,GAqBIA,EAAAe,2ECrBH,GAAAC,GAAA1pB,OAAA2pB,iBACDC,uBAAAvsB,QAAA,SAAAwsB,EAAAtb,GAAAsb,EAA+DD,UAAArb,IAGpD,SAAAsb,EAAAtb,GAAkB,IAAA,GAAAkU,KAAYlU,GAAAA,EAAAhP,eAAAkjB,KAAAoH,EAAApH,GAAAlU,EAAAkU,IAC9B,OAAA,UAAAoH,EAAAtb,GAWP,QAAAub,KAAA1uB,KAAAuH,YAEIknB,EAXRH,EAAAG,EAAAtb,GAkBQsb,EAAAjnB,UAAmB,OAAd2L,EAAcvO,OAAWiP,OAAAV,IAAAub,EAAAlnB,UAAA2L,EAAA3L,UAAA,GAAAknB,8BAGzBlvB,EAAa,cAAW4C,OAAA,UACjBzB,EAAK,mBACFA,EAAQ,mCACvBguB,gBAAkB,cAElBC,qBAAqB,2BACZ,mBACLC,GAAkBC,EAAKlH,EAAamH,EAAU1J,EAAA4B,EAAAd,EAAA6I,GAClDhvB,KAAC6nB,YAAAD,EACD5nB,KAAKivB,SAAWF,EAEhB/uB,KAAKkvB,aAAOJ,EACf9uB,KAAA+nB,WAAA1C,EAEOrlB,KAAAgoB,KAAAf,EACJjnB,KAAKmvB,QAAOhJ,OAACiJ,cAAOJ,EAGhBhvB,KAAAivB,UAAgBjvB,KAAAmvB,QAAAE,eAEpBrvB,KAAOkvB,aAAeb,SAAAruB,KAAAmvB,QAAAE,aAAAC,QAAA,aAAAtvB,KAAAkvB,aAAAb,SACtBruB,KAAAuvB,aAAoBvvB,KAAAkvB,aAAab,WAGjCruB,KAAKgoB,KAAAC,MAAA,mBAA4BjoB,KAAQkvB,aAAQb,UACjDruB,KAAKwvB,OAoFT,SAlFShoB,UAAc+nB,aAAiB,SAAWE,GAClD,GAAAA,EAAA,CAGG,GAAIC,UACAD,OAAKA,GAETC,EAASC,OAAQC,kBACbR,cAAaS,OAAA3K,QAAaze,QAAQipB,EAAiBI,SAAAJ,EAAsBI,QAACJ,EAAAI,QAAAC,OACjF/vB,KAAAovB,cAAAY,YAAA9K,QAAAze,QAAAipB,EAAAO,cAAAP,EAAAO,aAAAP,EAAAO,aAAAF,OAED/vB,KAAAovB,cAAWc,KAAAhL,QAAAze,QAAAipB,EAAAS,WAAQT,EAAAS,UAAAT,EAAAS,UAAAJ,YAAnBX,cAAAgB,UAAAV,EAAAW,kBACIjB,cAAYkB,eAAaZ,EAASa,MAAAC,QAGtChpB,UAAiCgoB,KAAA,WAC7BxvB,KAAI6nB,mBACAE,WAAKvoB,EAAamvB,iBAAiB3uB,KAAAkvB,aAAAb,eAEnCY,UAA0C,MAAhCjvB,KAAMmvB,QAAAE,mBAEhBF,QAAKE,aAAiBoB,QAAC,WAAazwB,KAAUkvB,aAAAb,iCAGzCQ,EAAiBrnB,UAAA,2BAE1B,MAACxH,MAAAkvB,aAAAb,0DAbJruB,KAAAkvB,aAAAb,SAAAjsB,EAgBMpC,KAAAgoB,KAAAC,MAAA,wBAAoB7lB,GACnBpC,KAAQuvB,aAASvvB,KAAAkvB,aAAAb,UACbruB,KAACwvB,OACFxvB,KAAK+nB,WAASyB,MAAAhqB,EAAAovB,qBAAAxsB,GACxBpC,KAAA+nB,WAAAyB,MAAAkH,EAAAC,kBAIAvI,YAAA,EAEMC,cAAA,IAEPwG,EAACrnB,UAAAopB,IAAA,SAAAvC,GAIA,MAFM,OAAAA,IACHruB,KAAOquB,SAAKA,GACfruB,KAAAquB,YAGe7mB,UAAAolB,gBAA4B,SAAMyB,EAAAwC,GACjD,MAAA7wB,MAAAkvB,aAAAtC,gBAAAyB,EAAAwC,MAGerpB,UAAAqpB,aAA0B,SAAMxC,EAASwC,GACxD,MAAA7wB,MAAAkvB,aAAAtC,gBAAAyB,EAAAwC,MAGerpB,UAAAomB,UAAa,SAAiB1mB,GAC7C,MAAAlH,MAAAkvB,aAAAtB,UAAA1mB,MAGeM,UAAAspB,eAAa,SAAoB9oB,GAChD,MAAAhI,MAAAkvB,aAAA4B,eAAA9oB,MAGeR,UAAAupB,aAAa,SAAuB/oB,EAAMgpB,EAAQC,GACjE,MAAAjxB,MAAAkvB,aAAA6B,aAAA/oB,EAAAgpB,EAAAC,MAGezpB,UAAA0pB,iBAAa,SAAwBzQ,EAAQuQ,EAAMC,GAClE,MAAAjxB,MAAAkvB,aAAAgC,iBAAAzQ,EAAAuQ,EAAAC,IArHLpC,EAsHCrnB,UAAA2pB,oBAAA,SAAAC,EAAAlqB,GAED,MAAAlH,MAAAkvB,aAAAiC,oBAAAC,EAAAlqB,IAMI2nB,EAAArnB,UAAA6pB,uBAAA,SAAAD,EAAAppB,EAAAgpB,EAAAC,GAAA,MAAAjxB,MACIkvB,aAAAmC,uBACHD,EAAAppB,EAAAgpB,EAAAC,MALOzpB,UAAyB8pB,wBAAA,SAAAF,EAAAppB,EAAAgpB,EAAAC,8DAOjCpC,OACgB,SAAW0C,WAG3BC,QACIlI,GAAKiI,EAAAvwB,KAAehB,OAAOA,WAC/BspB,GAACzB,aAAA,2BAJA2J,EAAAD,GAMD3sB,OAAAwe,eAAWoO,EAAAhqB,UAAA,kBAAX,WACI,MAAOxH,MAAK6nB,iBAGhB,SAAmBzlB,GACfpC,KAAK6nB,cAAazlB,mCAGfwC,OAAAwe,eAAAoO,EAAPhqB,UACI,WAKA+kB,IAAA,WAEI,MAAKvsB,MAAAivB,UAGTwC,IAAA,SAAYrvB,GACfpC,KAAAivB,WAAA7sB,GAtC2BgmB,YAAA,EAyChCC,cAAA,IAECmJ,EAAAhqB,UAAAghB,MAAA,aAAA,OAAA,UAAA,gBAAA,SAAAnD,EAAA4B,EAAAd,EAAA6I,GAEM,UAGC,OAFmB,OAAfhvB,KAAAuoB,WACPvoB,KAASuoB,SAAc,GAAEsG,GAAkB7uB,KAAAA,KAAA6nB,YAAA7nB,KAAAivB,SAAA5J,EAAA4B,EAAAd,EAAA6I,IACvChvB,KAAAuoB,4CD5KD,wCACUiJ,4CAES,GAAAE,gBAAA,KAAAC,IAAA,SAAAhxB,EAAAlB,EAAAD,sCAETA,EAAQ,cAAA4C,OAAA,UACd,mBACHwvB,UACDC,UAAI,6BAGAC,GAAM,UACNC,GAAM,UACNC,GAAM,UACNC,GAAM,aACTC,GAAA,SACHC,GAAA,UAIFJ,IAAAD,GAAA,aACAC,GAAA,4CADwDG,GAAA,WAGjDC,GAAA,gBExBX,MF4BIvtB,QAACwe,eAAAwO,EAAApqB,UAAA,YAGM+kB,IAAA,WAAA,MAAAvsB,MAAA6xB,WACHJ,IAAI,SAAWrvB,GAAApC,KAAc6xB,UAASzvB,GACtCgmB,YAAK,EACRC,cAAA,MAIQ7gB,UAAAopB,IAAgB,SAAUvC,GAK/B,MAJH,OAAAA,IAGMruB,KAAA6xB,UAAAxD,GACGruB,KAAM6xB,aAERrqB,UAAYolB,gBAAQ,SAAmByB,EAAUwC,GACrD,GAAAzjB,GAAOpN,KAAAoyB,cAAqB/D,MAC/BruB,MAAAoyB,cAAA/D,GAAAlkB,EAAAuc,OAAAtZ,EAAAyjB,MAISrpB,UAAYqpB,aAAe,SAAMxC,EAAAwC,QAACjE,gBAAUyB,EAAAwC,MAG9CrpB,UAAYomB,UAAQ,SAAc1mB,GAEtC,MAAEiD,GAAIkoB,OAAOnrB,IAAAiD,EAAUmoB,YAASprB,GACrB,IACKlH,KAAAoyB,cAAqBpyB,KAAK6xB,gBACvC3qB,IAAAA,GAGP0qB,EAACpqB,UAAAspB,eAAA,SAAA9oB,GAGM,GAAAmC,EAAAkoB,OAAArqB,IAAP,GAAOA,EAAA/G,OACC,YAAoCke,MAExC0R,EAAiB7wB,KAAIoyB,cAAKpyB,KAAA6xB,qBAC1B1nB,GAAAuX,KAAA1Z,EAAY,SAASmP,GAEjB,GAAAjQ,GAAgBiQ,GAAG,EACnBgI,GAAA/X,KAAYypB,EAAQ3pB,IAAaA,KAGjCiY,KAGA3X,UAAcupB,aAAO,SAAA/oB,EAAAgpB,EAAAC,MACrB9mB,EAAAkoB,OAAMrqB,IAA0B,GAAhBA,EAAG/G,OAEnB,QACJ+vB,GAAGA,GAAA,KAEHC,EAAOA,GAAO,MACjB,IAAA9R,MAGM0R,EAAA7wB,KAAAoyB,cAAPpyB,KAAA6xB,qBACI1nB,GAAEuX,KAAI1Z,EAAO,SAAUd,GAAmB,GAAA9E,KAE1C8E,GAAUA,GAAO,GACjB9E,EAAS4uB,GAAY9pB,EAEjB9E,EAAA6uB,GAAmBJ,EAAC3pB,IAAmBA,EAEzCiY,EAAK/X,KAAOhF,KAGV+c,KAGG3X,UAAM0pB,iBAAA,SAAAzQ,EAAAuQ,EAAAC,GAChB,GAAA9mB,EAAAkoB,OAAA5R,IAAA,GAAAA,EAAAxf,OAGM,QACH+vB,GAASA,GAAS,OAClBC,EAAOA,GAAc,WACrB,IAAIJ,GAAY7wB,KAAAoyB,cAAApyB,KAAA6xB,cAGlB,eAHmBpR,EAAU,SAAAnY,GACvB,GAAApB,GAAAoB,EAAe0oB,IAAK,EACxB1oB,GAAO2oB,GAAaJ,EAAY3pB,IAAAA,IAClCuZ,KAGQjZ,UAAY2pB,oBAAqB,SAAAC,EAAAlqB,GAGvC,SAHwCkqB,EAAUA,EAAA,IAAA,GAGxC,OADVlqB,GAAMkqB,EAASlqB,GAAG2F,QAAO,KAAQ,KAAM0lB,eAE9B,IAEOvyB,KAAAoyB,cAAApyB,KAAA6xB,gBACG3qB,IAAKA,KAIjBM,UAAU6pB,uBAAG,SAAAD,EAAAppB,EAAAgpB,EAAAC,MAEhB9mB,EAAAkoB,OAAMrqB,IAAe,GAAJA,EAAI/G,OACrB,WAEAmwB,EAAYA,EAAOvkB,QAAA,KAAA,KAAA0lB,cAAA,GACvBvB,EAAGA,GAAA,KAEHC,EAAOA,GAAO,MACjB,IAAA9R,MAGM0R,EAAA7wB,KAAAoyB,cAAApyB,KAAuB6xB,cAU1B,OATA1nB,GAAEuX,KAAI1Z,EAAO,SAASd,GAAkB,GAAA9E,KAExC8E,GAAUA,GAAO,GACjB9E,EAAS4uB,GAAY9pB,EACrB9E,EAAS6uB,GAASJ,EAAeO,EAAW,IAAAlqB,IAAaA,EAErDiY,EAAM/X,KAAMhF,KAGT+c,KAEA3X,UAAU8pB,wBAAG,SAAAF,EAAAppB,EAAAgpB,EAAAC,MAEhB9mB,EAAAkoB,OAAMrqB,IAAe,GAAJA,EAAI/G,OACrB,cACiB,OAEVgwB,GAAY,OACvBG,EAAGA,EAAAA,EAAAvkB,QAAA,KAAA,KAAA0lB,cAAA,IAAA,EAEH,IAAApT,MACH0R,EAAA7wB,KAAAoyB,cAAApyB,KAAA6xB,qBACL1nB,GAAAuX,KAAA1Z,EAAA,SAACd,GAAA,GAAA9E,KAnKY8E,GAAAA,GAAA,0GEEb0qB,IAEApyB,GAAAoyB,YAAAA,OACAY,IAAA,SAAA7xB,EAAAlB,EAA8BD,GAE9B,YAEA,SAAA2lB,GAAAiC,oGCPAlC,QAAAzlB,OAAA,qBAAA,mBAgBC,wBAdU,uBACH,4BAAmB,oBAEnBkB,EAAI,gDACa,GAAG8xB,oBAAiB,GAAAC,qBAAA,GAAAhB,gBAAA,KAAAiB,IAAA,SAAAhyB,EAAAlB,EAAAD,sCAGvBA,EAAA,cAAA4C,OAAA,OAClBwwB,GAAC,WAGM,QAAAA,YAEPA,GAACprB,UAAAqrB,KAAA,SAAAzwB,GACL,GAAC,MAADA,EAAC,MAAA,EAGI,KAAO,GADLO,GAAA,EACK/B,EAAA,EAAYA,EAAGwB,EAAAnB,OAAAL,IACf+B,GAACP,EAAY0wB,WAAOlyB,iDCpBhC,MAAA+P,MAAAoiB,SAAAtmB,SAAA,IAAAumB,OAAA,EAAA,IAAAT,eAEYK,oBAIA,uBACA,WAAUA,YACb,SAAAjyB,EAAAlB,EAAAD,sCAGQA,EAAc,cAAe4C,OAAO,UACvC,mBAEN6wB,KACHjzB,KAAAkzB,SCXM,SDcA1rB,UAAU2rB,OAAC,SAAA/wB,EAAAgxB,OACVhxB,GAAU,IAAAA,EACb,MAAA,EAED,IAAAnB,GAAamB,EAAIixB,QAAA,eACTpyB,GAAQ,EAAAA,EAAAmB,EAAAnB,SAACA,EAAUmyB,EAAIhxB,EAAAnB,OAAAmyB,EACxBhxB,EAAMkxB,UAAS,EAAIryB,MAE1BuG,UAAa+rB,UAAC,SAAAC,EAAAC,GACjB,GAAAA,EAAA,EAEO,MAAA,EAIA,KAFP,GAAA9wB,GAAA,GAEO8wB,EAAA,GACkB,EAAdA,IACD9wB,GAAO6wB,GACVC,IAAK,EAAKD,GAAGA,QAEZ7wB,gBAEG+wB,QAAe,SAAMC,SACxBlnB,UAAAzL,KAAA2yB,GAAA1lB,MAAA,GAAA,GAAA2lB,2BAEOC,YAAW,SAAAC,eACXxnB,KAAeynB,KAAAC,EAAA,KACf,IACmB,UAAd,YAAWC,KAAGC,MACf9sB,KAAAkF,EAAW,YAEY,UAAjB,WAAG2nB,KAAWC,WACZ,aAEqE,UAAzE,uFAAyED,KAAAC,IAkCxF,KAAS,IAAGrzB,OAAG,6BAhCC,WACKszB,EAAA7nB,EAAA,GAAA8nB,QAC+B,UAA3B,sBAAUH,KAAiBE,IAejD,KAAW,IAAKtzB,OAAO,gBAbf,OADKuG,KAAAgtB,EAAA,IACJ,MAAAD,EAAAA,EAAAb,UAAAc,EAAA,GAAAnzB,UACJ,GAAA,QAAAmzB,EAAA,wBAAAH,KAAAE,IACKE,EAAAjtB,KAAAgtB,EAAA,QAEL,CAAA,GAAA,QAAAA,EAAA,aAAAH,KAAAE,IAIQ,KAAM,IAAAtzB,OAAA,gBAHJwzB,GAAWjtB,KAAAgtB,EAAA,IAUxB9nB,EAAA,GAAA+nB,MAGCL,IAAc,CAElB,IAAW,IAAXA,EACV,KAAA,IAAAnzB,OAAA,kEAGOkzB,GAAmB3sB,KAAAkF,GAMnB4nB,EAAIA,EAAAZ,UAAchnB,EAAU,GAACrL,cAE5B8yB,gBAEOhE,OAAQ,SAAYgE,EAAExP,aACtB,IACMwP,EAAK9yB,cAEX,EAAIL,EAAC0zB,EAAe1zB,IAAM,OAClBZ,KAAK0zB,QAAAK,EAAenzB,OACpB,oBACHmzB,EAAAnzB,YAEJ,UAAA2zB,EAAA,CACL,GAACjoB,GAAAynB,EAAAnzB,GAAK+G,MAAK,MACP2E,EAAM,GAAI,CACb3E,EAAA4c,EAAAiQ,EACG,KAAE,GAAArd,GAAA,EAAAA,EAAA7K,EAAA,GAAArL,OAAAkW,IAAA,CACC,IAAGxP,EAAKxD,eAAUmI,EAAA,GAAA6K,IACxB,KAAA,IAAAtW,OAAAb,KAAAy0B,QAAA,+BAAAnoB,EAAA,GAAA6K,IAGGxP,GAAUA,EAAA2E,EAAU,GAAC6K,YAGhB7K,EAAG,GAAEiY,EAAMjY,EAAI,IACViY,EAAMiQ,QAChB,OAAKtuB,KAAGoG,EAAA,KAAA,UAAAtM,KAAA0zB,QAAA/rB,QAAE,IAAM9G,OAAAb,KAASy0B,QAAS,gCAAAz0B,KAAA0zB,QAAA/rB,YAClC2E,EAAQ,QAAE,IAAoE3E,EAAMA,EAAA8E,SAAA,EACpF,WAAU,IAAsE9E,EAAMV,OAAAytB,aAAA/sB,EACtF,WAAU,IAAuBA,EAAMgtB,SAAAhtB,EAAA,GACvC,WAAU,IAA4EA,EAAM2E,EAAA,GAAA3E,EAAAitB,cAAAtoB,EAAA,IAAA3E,EAAAitB,eAC5F,WAAU,IAAqBjtB,EAAM2E,EAAA,GAAAuoB,WAAAltB,GAAAmtB,QAAAxoB,EAAA,IAAAuoB,WAAAltB,EACrC,WAAU,IAAwBA,EAAMA,EAAA8E,SAAA,EACxC,WAAU,IAAsC9E,GAAMA,EAAAV,OAAAU,KAAA2E,EAAA,GAAA3E,EAAA2rB,UAAA,EAAAhnB,EAAA,IAAA3E,CACzD,MACE,KAAI,IACHA,EAAAgJ,KAAaokB,IAAGptB,EAChB,MACA,KAAG,IACAA,EAAKA,EAAM8E,SAAQ,GAC7B,MACJ,KAAA,IACa9E,EAAQA,EAAC8E,SAAA,IAAA8lB,cAGK5qB,EAAc,QAAAzB,KAAAoG,EAAA,KAAAA,EAAA,IAAA3E,GAAA,EAAA,IAAAA,EAAAA,CAAd,IAAAqtB,GAAA1oB,EAAA,GAAc,KAAAA,EAAA,GAAA,IAAAA,EAAA,GAAA2oB,OAAA,GAAA,IAAdC,EAAA5oB,EAAA,GAAcrF,OAAAU,GAAA1G,oCACrCk0B,GAAU/tB,KAACkF,EAAA,GAAe3E,EAAAytB,EAASA,EAAAztB,IAI3C,MAAAwtB,GAAApoB,KAAA,OAGMvF,UAAOitB,QAAS,SAAA3xB,GACnB,IAAI,GADgBtB,MAChB6zB,EAAS,EAAGA,EAAAvzB,UAAAb,OAAAo0B,IAEZ7zB,EAAK6zB,EAAG,GAAIvzB,UAASuzB,eAEjBnC,MAAM/uB,eAAQrB,KAElB9C,KAAIkzB,MAAKpwB,GAAa9C,KAAE6zB,YAAA/wB,IACrB9C,KAAC+vB,OAAS/vB,KAAKkzB,MAAApwB,GAAAtB,gBAEd8zB,eAAA,SAAAzV,MACM,QACb,MAAA,KAED,IAAAld,GAAa,EAChB,KAAA,GAAAuE,KAAA2Y,GAAA,CAEMld,EAAA1B,OAAA,IACC0B,GAAY,IAEZ,IAAAP,GAASyd,EAAQ3Y,EAGhBvE,IAFY,MAAbP,EAEa8E,EAAG,IAAM9E,EAER8E,EAElB,MAACvE,IAGLswB,EAACzrB,UAAA+tB,cAAA,SAAAvzB,GAEM,GAAAW,GAAA,EACH,IAAoB,MAAhBX,GAAmB,GAAAA,EAAAf,OACnB,MAAI0B,EAER,KAAK,GAAG/B,GAAI,EAAIA,EAAAoB,EAAAf,OAAAL,IACR+B,EAAI1B,OAAA,IACJ0B,GAAO,KAEfA,GAAcX,EAAApB,EAChB,OAAA+B,IAvLNswB,EAwLCzrB,UAAAguB,YAAA,SAAA9sB,GAGM,GACKxB,GADLvE,IAEF,KAAQuE,IAAAwB,+CCzLFuqB,IAIX/N,SAKIzlB,OAAA,wBAKS,YAAawzB,YAClB,SAAStyB,EAAQlB,EAAAD,wBCAxBi2B,GAAApQ,EAAAqQ,GAhBUrQ,EAAAC,IAAA9lB,EAAAmxB,eAAP,WAAgB+E,EAAe3K,YACtBzF,IAAA9lB,EAAam2B,eAAiB,SAACpQ,EAAAqQ,GAAAF,EAAAG,UAAAD,ODkBpC9O,SAAW,aAAa,sCACbtnB,EAAA,cAAoB4C,OAAK,MACvCuuB,eAAA,iBAEMgF,eAAA,iBACHG,aAAe,WACfC,iBAAkB,gBACtBC,GAAC,mBAGQA,GAAW3Q,EAAA4B,EAAwBgP,GACxCj2B,KAAK+nB,WAAa1C,EACrBrlB,KAAAgoB,KAAAf,EAEOjnB,KAAAk2B,SAAAD,EAAR5Q,EAAA7lB,EAQCs2B,eAAA,EAPGzQ,EAAK7lB,EAAWu2B,kBAAa,KCpCrC,MD8BWC,GAAAlP,SAAA,aAAP,OAAiB,cASAtf,UAACujB,MAAA,gBACV/C,KAAKC,MAAA,kCACLkO,aAAK,OAEbH,EAACxuB,UAAAquB,UAAA,SAAAD,GACL51B,KAAAgoB,KAAAC,MAAA,sBAAC2N,GAAA51B,KAAAm2B,aAAAP,IAOGI,EAAexuB,UAAA2uB,aAAgB,SAAAP,GAC/B,GAAAtM,GAAetpB,IAClBA,MAAA+nB,WAAAvoB,EAAAs2B,cAAA,MAAAF,EAGO51B,KAAA+nB,WAAOvoB,EAAgBu2B,kBAAGH,EAC7B51B,KAAQk2B,SAAA,WACJ5M,EAAAvB,WAAiBvoB,EAAAs2B,eAAA,6CC1D1BE,aAIQv2B,OAAI,2BAAgC,eAAiBu2B,OAErDP,qBACW90B,EAAAlB,EAAcD,sCACjBA,EAAc,cAAM4C,OAAe,UACnC,yBCFZ,SDIYoF,UAAA4uB,SAAsB,SAAAC,EAAAC,EAAAC,MACPD,QAEZz0B,QACR00B,EAAK,KACXloB,WAAA,WAEL,GAAAmoB,EAAAF,GAACG,WAAD,CAIY,KADL9lB,KAAAokB,IAAAyB,EAAAH,GAAAK,YAAAF,EAAAF,GAAAG,WAAAE,KACkB,IAAb,oECtBZD,UAAAN,EAAA,MAGIG,MACI,OAGHK,oBAIG,wBAEA,YAAcA,qBAAcj2B,EAAOlB,EAAOD,sCACRA,EAAM,cAAA4C,OAAA,UAClC,mBACNy0B,GAAO1Q,mBACPgJ,QAAOhJ,oBAF+B,iCAGxB0Q,EAAWrvB,UAAC,8BAC1B,GAAIsvB,GAAG92B,KAAOmvB,QAAA4H,UAAkBC,gBAACF,GAAAG,OAAO,SAAY,EAC7C,OAAuBH,EAAAG,OAAO,SAAS,EACvC,KAAuBH,EAAAG,OAAO,YAAS,EACvC,KAAwBH,EAAAG,OAAO,YAAU,EAEzC,UACVH,EAAAG,OAAA,UAAA,6BAAA,QAEDH,EAAAG,OAAW,cAAA,EAAX,YACQH,EAAAG,OAAQ,WAAA,EACH,SACLH,EAAAG,OAAU,WAAK,EAEX,SACJH,EAAAG,OAAK,YAAM,EACP,iCAGA,gBACA,0BAECJ,EAAMrvB,UAAA,yCAGPxH,KAAMmvB,QAAA4H,UAAAC,UACV3S,EAAKrkB,KAASk3B,mBACV7S,OACA,OACJG,EAAYsS,EAAA5qB,MAAA,QAAA,GAAA4qB,EAAA5qB,MAAA,QAAA,GAAAA,MAAA,KAAA,GAAA,IACR,WACA,KACJ,GAAKirB,GAAWL,EAAA5qB,MAAA,SAAA,GAAA4qB,EAAA5qB,MAAA,SAAA,GAAA4qB,EAAA5qB,MAAA,YAAA,EACZsY,GAAU2S,EAAUA,EAAcjrB,MAAM,KAAI,GAAM,IAClD,MACJ,KAAK,OACDmY,EAAU,KACVG,EAAMsS,EAAA5qB,MAAA,SAAA,GAAA4qB,EAAA5qB,MAAA,SAAA,GAAAA,MAAA,KAAA,GAAA,IACV,WACI,UACAsY,EAAMsS,EAAA5qB,MAAA,YAAA,EACV,WACI,QACAsY,EAAMsS,EAAAG,OAAA,UAAA,EAAAH,EAAA5qB,MAAA,YAAA,GAAA4qB,EAAA5qB,MAAA,QAAA,EACb,MAED,KAAO,YACVsY,EAAAsS,EAAA5qB,MAAA,cAAA,GAAA4qB,EAAA5qB,MAAA,cAAA,GAAAA,MAAA,KAAA,GAAA,wBAAAsY,EAAAsS,EAAA5qB,MAAA,WAAA,GAAA4qB,EAAA5qB,MAAA,WAAA,GAAAA,MAAA,KAAA,GAAA,IAED,MAAA,KAAA,SACUsY,EAAQsS,EAAQ5qB,MAAA,WAAU,GAAU4qB,EAAA5qB,MAAA,WAAA,GAAAA,MAAA,KAAA,GAAA,IAEtC,MACA,KAAA,UAEGsY,EAAUsS,EAAA5qB,MAAA,YAAA,aAGrBkc,YAAA,gBAAA,0BAGSyO,EAAArvB,UAAA,iCAGD,6DAA4DtB,KADxDlG,KAAAmvB,QAAa4H,UAAWC,UACoCpD,eACnE,SAAQ,uBAER,EACLvL,cAAC,4CAAAkE,IAAA,WAEM,GAAAuK,GAAA92B,KAAAmvB,QAAS4H,UAAhBC,SACI,KACH,GAAAI,IAAA,8DAAAnD,KAAA6C,EAAAlD,iBAAAkD,IAAA,GAAAjqB,QAAA,QAAA,WAEMwqB,EAAQ,YAAfpD,KAAA6C,EAAAlD,gBAAA,EACW,QAAKyD,GAAqB,WAATA,GAAS,WAAAA,EAAA,GAAAD,EAAA,UAI9B,MAAAv0B,GACI,MAAM,YAKbulB,YAAK,gBACQ,gBAECkP,UAAA,iBACK,gBAAXC,sBAEQC,SAAE,iBACC,eAAXD,YAGJ/vB,UAAUiwB,UAAK,WACnB,OAAI,KAGAjwB,UAAWkwB,YAAU,SAAY10B,GACjCA,IAEJA,GACH20B,KAAA,GACLC,GAAA,GAACC,QAAA,GAGMC,MAAA,GACKC,OAAA,GACCC,OAAA,kDChIb,OAAAxT,GAAAA,EAAAtY,MAAA,KAAA,GAAAmY,GAAArhB,EAAAqhB,IAAArhB,EAAAqhB,IAsDC,gBA9CU5kB,OAAA,4BACH,gBAAUo3B,qBACAl2B,EAAQlB,EAAAD,uBAErB4jB,eAAA5jB,EAAA,cAAA4C,OAAA,OAEM61B,GAAA,mBACCA,MCNZ,SDQQzwB,UAAQ0wB,aAAgB,SAAS7zB,SAC7BA,GACE8F,EAACuC,KAAKrI,EAAAwI,QAAY,UAAS,MACpC,QAEDrF,UAAA2wB,YAOC,SAAA9zB,GANG,MAAMA,GACFA,EAAIwI,QAAQ,WAAM,IAAY+mB,cAE9B,MAGRqE,EAACzwB,UAAA4wB,MAAA,SAAAC,EAAAC,GAEM,MAAA,OAAAD,GAAP,MAAOC,GACG,MAAFD,GAAiB,MAADC,GAGbt4B,KAAKm4B,YAAOE,IAAYr4B,KAAKm4B,YAAKG,IAG7CL,EAACzwB,UAAA+wB,aAAA,SAAAC,GAEM,GAAAlP,GAAAtpB,WAAPmK,GAAAsuB,SAAAD,KACQA,EAAOA,EAAKtsB,MAAA,aAEhBssB,EAAOruB,EAAAiD,IAAAorB,EAAY,SAAEn0B,GAAM,MAAAilB,GAAA4O,aAAA7zB,kBAInBq0B,YAAe,SAAWF,SACtBx4B,IAKf,OAJOmK,GAACsuB,SAAAD,KACFA,EAAAA,EAAAtsB,MAAA,aAEHssB,EAAOruB,EAAEiD,IAAIorB,EAAM,SAACn0B,GAAA,MAAAilB,GAAA6O,YAAA9zB,MApD5B4zB,EAsDCzwB,UAAAmxB,QAAA,SAAAC,EAAAC,GAGM,GAAAvP,GAAAtpB,KACKw4B,EAAAx4B,KAAWu4B,aAAGK,EAAAJ,KCnDlB,ODoDHruB,GAAAuX,KAAQmX,EAAgB,SAACC,kDC3D9BN,GAAAA,EAAAx0B,OAAAslB,EAAAiP,aAAAQ,OAOa5uB,EAAA6uB,KAAOR,IAEpBP,IAGA/S,SACIzlB,OAAI,cACJ+sB,QAAI,UAAWyL,QACfgB,IAAI,SAAWt4B,EAAAlB,EAAAD,eAInBoF,QAAAwe,eAAA5jB,EAAA,cAAA4C,OAAA,OAOI82B,GAAA,mBAKIA,GAAW3T,EAAAtP,GARPjW,KAAAulB,MAAQA,EACRvlB,KAAAiW,QAAwBA,QAU5BijB,MAEJC,GAEO,GAAAD,GAAA,qBAAP,QACIA,GAAW,oBAAU,MACzB,GAACA,GAAA,0BAAA,QAGO,mBACuBE,GAAO/T,EAAA4B,EAAAoS,GAElC,gBACIC,UAAY,OACZC,QAASpvB,EAAAsc,UAAO0S,QAClBpR,WAAA1C,EACFrlB,KAAKgoB,KAAOf,EAEZjnB,KAAIw5B,UAAaH,WARbvS,SAAa,aAAS,OAAA,aAU9BsS,EAAC5xB,UAAAiyB,UAAA,WAEM,MAAAz5B,MAAAs5B,YAEK9xB,UAAAkyB,SAAqB,SAAWnU,EAAAtP,MAE3B,MADL9L,EAAc8Y,KAAKjjB,KAAIu5B,QAAQ,SAAAp5B,GAAA,MAAAA,GAAAolB,OAAAA,QAGnCoU,IACHpU,MAAAA,EACJtP,QAAAA,EAGGjW,MAAKu5B,QAAOnyB,KAAAuyB,GACR35B,KAACs5B,UACRt5B,KAAA45B,WAAAD,OAEDnyB,UAQCqyB,YAAA,SAAAtU,GAPG,IAAK,GAAC3kB,GAAAZ,KAAWu5B,QAAKt4B,OAClB,EAAAL,GAAA,EAAAA,IAAA,CACI,GAAAk5B,GAAgB95B,KAAAu5B,QAAA34B,EAChBk5B,GAAgBvU,OAAMA,IAErBvlB,KAAC+5B,UACTD,GACJ95B,KAAAu5B,QAAAtpB,OAAArP,EAAA,QAKW4G,UAAKwyB,YAAiB,gBACzBvQ,YAAC8P,cAGG/xB,UAASoyB,WAAQ,SAAArU,GAC1B,GAAC+D,GAAAtpB,IACJulB,GAAA7P,SAAA1V,KAAAw5B,UAAA,WAEMlQ,EAAAtB,KAAAC,MAAA,yBAAP1C,EAAAA,OAAA+D,EAAAvB,WAQCyB,MAAAjE,EAAAA,QAPMA,EAAMtP,YAEFzO,UAAYuyB,UAAG,SAAKxU,MACP,MAAhBA,EAAK7P,SAAkB,CACxB,IAEE1V,KAAQw5B,UAAQS,OAAA1U,EAAA7P,UAGlB,MAAAwkB,IACD3U,EAAK7P,SAAc,SAIhBlO,UAAW9F,MAAM,WACzB,GAAA4nB,GAAAtpB,IACLA,MAAAs5B,WAGQnvB,EAAAuX,KAAO1hB,KAAAu5B,QAAc,SAAChU,GAClB+D,EAACsQ,WAAYrU,wBCnHzB6T,EAAA5xB,UAAkBiiB,KAAA,WAClB,GAAAH,GAAAtpB,IACAmK,GAAAuX,KAAA1hB,KAAAu5B,QAAyB,SAAAhU,GACzB+D,EAAgByQ,UAAAxU,KAEhBvlB,KAAAs5B,UAAsB","file":"pip-webui-services.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest$1(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n// Lodash rest function without function.toString()\n// remappings\nfunction rest(func, start) {\n    return overRest$1(func, start, identity);\n}\n\nvar initialParams = function (fn) {\n    return rest(function (args /*..., callback*/) {\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    });\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous funuction, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function (value) {\n                callback(null, value);\n            }, function (err) {\n                callback(err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction supportsAsync() {\n    var supported;\n    try {\n        /* eslint no-eval: 0 */\n        supported = isAsync(eval('(async function () {})'));\n    } catch (e) {\n        supported = false;\n    }\n    return supported;\n}\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nvar wrapAsync$1 = supportsAsync() ? wrapAsync : identity;\n\nfunction applyEach$1(eachfn) {\n    return rest(function (fns, args) {\n        var go = initialParams(function (args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync$1(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        } else {\n            return go;\n        }\n    });\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  value = Object(value);\n  return (symToStringTag && symToStringTag in value)\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? { value: obj[key], key: key } : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function () {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (value === breakLoop || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if (++completed === length || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function (coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync$1(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply$2 = rest(function (fn, args) {\n    return rest(function (callArgs) {\n        return fn.apply(null, args.concat(callArgs));\n    });\n});\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function (val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = wrapAsync$1(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20f0';\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg) {\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync$1(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return rest(function (fn, args) {\n        defer(function () {\n            fn.apply(null, args);\n        });\n    });\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function (node) {\n    if (node.prev) node.prev.next = node.next;else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = DLL;\n\nDLL.prototype.insertAfter = function (node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function (node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function (node) {\n    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);\n};\n\nDLL.prototype.push = function (node) {\n    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);\n};\n\nDLL.prototype.shift = function () {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function () {\n    return this.tail && this.removeLink(this.tail);\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    } else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync$1(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    }\n\n    function _next(tasks) {\n        return rest(function (args) {\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n                var index = baseIndexOf(workersList, task, 0);\n                if (index >= 0) {\n                    workersList.splice(index);\n                }\n\n                task.callback.apply(task, args);\n\n                if (args[0] != null) {\n                    q.error(args[0], task.data);\n                }\n            }\n\n            if (numRunning <= q.concurrency - q.buffer) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        });\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated: noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {\n                var tasks = [],\n                    data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    data.push(node.data);\n                }\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n                numRunning += 1;\n                workersList.push(tasks[0]);\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function () {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) {\n                return;\n            }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n  return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    eachOfSeries(coll, function (x, i, callback) {\n        _iteratee(memo, x, function (err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nvar seq$1 = rest(function seq(functions) {\n    var _functions = arrayMap(functions, wrapAsync$1);\n    return rest(function (args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function (newargs, fn, cb) {\n            fn.apply(that, newargs.concat(rest(function (err, nextargs) {\n                cb(err, nextargs);\n            })));\n        }, function (err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    });\n});\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = rest(function (args) {\n  return seq$1.apply(null, args.reverse());\n});\n\nfunction concat$1(eachfn, arr, fn, callback) {\n    var result = [];\n    eachfn(arr, function (x, index, cb) {\n        fn(x, function (err, y) {\n            result = result.concat(y || []);\n            cb(err);\n        });\n    }, function (err) {\n        callback(err, result);\n    });\n}\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doParallel(concat$1);\n\nfunction doSeries(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOfSeries, obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doSeries(concat$1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = rest(function (values) {\n    var args = [null].concat(values);\n    return initialParams(function (ignoredArgs, callback) {\n        return callback.apply(this, args);\n    });\n});\n\nfunction _createTester(check, getResult) {\n    return function (eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function (value, _, callback) {\n            iteratee(value, function (err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return rest(function (fn, args) {\n        wrapAsync$1(fn).apply(null, args.concat(rest(function (err, args) {\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        })));\n    });\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync$1(fn);\n    var _test = wrapAsync$1(test);\n\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        args.push(check);\n        _test.apply(this, args);\n    });\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function () {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync$1(fn);\n    var _test = wrapAsync$1(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({ index: index, value: x });\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync$1(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync$1(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function (coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync$1(iteratee);\n    mapLimit(coll, limit, function (val, callback) {\n        _iteratee(val, function (err, key) {\n            if (err) return callback(err);\n            return callback(null, { key: key, val: val });\n        });\n    }, function (err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync$1(iteratee);\n    eachOfLimit(obj, limit, function (val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync$1(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function () {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(rest(function (args) {\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            })));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `setImmediate`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @alias setImmediate\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync$1(task)(rest(function (err, args) {\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            results[key] = args;\n            callback(err);\n        }));\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n  _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n  _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n  var _worker = wrapAsync$1(worker);\n  return queue(function (items, cb) {\n    _worker(items[0], cb);\n  }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function (worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function (data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync$1(tasks[i])(callback);\n    }\n}\n\nvar slice = Array.prototype.slice;\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight(array, memo, iteratee, callback) {\n  var reversed = slice.call(array).reverse();\n  reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync$1(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(rest(function callback(err, cbArgs) {\n            if (err) {\n                reflectCallback(null, {\n                    error: err\n                });\n            } else {\n                var value = null;\n                if (cbArgs.length === 1) {\n                    value = cbArgs[0];\n                } else if (cbArgs.length > 1) {\n                    value = cbArgs;\n                }\n                reflectCallback(null, {\n                    value: value\n                });\n            }\n        }));\n\n        return _fn.apply(this, args);\n    });\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function (value, cb) {\n        iteratee(value, function (err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function (task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync$1(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync$1(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n  _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy(coll, iteratee, callback) {\n    var _iteratee = wrapAsync$1(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, { value: x, criteria: criteria });\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria,\n            b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var originalCallback, timer;\n    var timedOut = false;\n\n    function injectedCallback() {\n        if (!timedOut) {\n            originalCallback.apply(null, arguments);\n            clearTimeout(timer);\n        }\n    }\n\n    function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n            error.info = info;\n        }\n        timedOut = true;\n        originalCallback(error);\n    }\n\n    var fn = wrapAsync$1(asyncFn);\n\n    return initialParams(function (args, origCallback) {\n        originalCallback = origCallback;\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args.concat(injectedCallback));\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax$1 = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n  var _iteratee = wrapAsync$1(iteratee);\n  mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform(coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n\n    eachOf(coll, function (v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function (err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    if (!test()) return callback(null);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function () {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function (tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        if (taskIndex === tasks.length) {\n            return callback.apply(null, [null].concat(args));\n        }\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            if (err) {\n                return callback.apply(null, [err].concat(args));\n            }\n            nextTask(args);\n        }));\n\n        args.push(taskCallback);\n\n        var task = wrapAsync$1(tasks[taskIndex++]);\n        task.apply(null, args);\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n  applyEach: applyEach,\n  applyEachSeries: applyEachSeries,\n  apply: apply$2,\n  asyncify: asyncify,\n  auto: auto,\n  autoInject: autoInject,\n  cargo: cargo,\n  compose: compose,\n  concat: concat,\n  concatSeries: concatSeries,\n  constant: constant,\n  detect: detect,\n  detectLimit: detectLimit,\n  detectSeries: detectSeries,\n  dir: dir,\n  doDuring: doDuring,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  during: during,\n  each: eachLimit,\n  eachLimit: eachLimit$1,\n  eachOf: eachOf,\n  eachOfLimit: eachOfLimit,\n  eachOfSeries: eachOfSeries,\n  eachSeries: eachSeries,\n  ensureAsync: ensureAsync,\n  every: every,\n  everyLimit: everyLimit,\n  everySeries: everySeries,\n  filter: filter,\n  filterLimit: filterLimit,\n  filterSeries: filterSeries,\n  forever: forever,\n  groupBy: groupBy,\n  groupByLimit: groupByLimit,\n  groupBySeries: groupBySeries,\n  log: log,\n  map: map,\n  mapLimit: mapLimit,\n  mapSeries: mapSeries,\n  mapValues: mapValues,\n  mapValuesLimit: mapValuesLimit,\n  mapValuesSeries: mapValuesSeries,\n  memoize: memoize,\n  nextTick: nextTick,\n  parallel: parallelLimit,\n  parallelLimit: parallelLimit$1,\n  priorityQueue: priorityQueue,\n  queue: queue$1,\n  race: race,\n  reduce: reduce,\n  reduceRight: reduceRight,\n  reflect: reflect,\n  reflectAll: reflectAll,\n  reject: reject,\n  rejectLimit: rejectLimit,\n  rejectSeries: rejectSeries,\n  retry: retry,\n  retryable: retryable,\n  seq: seq$1,\n  series: series,\n  setImmediate: setImmediate$1,\n  some: some,\n  someLimit: someLimit,\n  someSeries: someSeries,\n  sortBy: sortBy,\n  timeout: timeout,\n  times: times,\n  timesLimit: timeLimit,\n  timesSeries: timesSeries,\n  transform: transform,\n  unmemoize: unmemoize,\n  until: until,\n  waterfall: waterfall,\n  whilst: whilst,\n\n  // aliases\n  all: every,\n  any: some,\n  forEach: eachLimit,\n  forEachSeries: eachSeries,\n  forEachLimit: eachLimit$1,\n  forEachOf: eachOf,\n  forEachOfSeries: eachOfSeries,\n  forEachOfLimit: eachOfLimit,\n  inject: reduce,\n  foldl: reduce,\n  foldr: reduceRight,\n  select: filter,\n  selectLimit: filterLimit,\n  selectSeries: filterSeries,\n  wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.apply = apply$2;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq$1;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import './translate';\r\nimport './session';\r\nimport './transactions';\r\nimport './routing';\r\nimport './utilities';\r\n\r\nangular.module('pipServices', [\r\n    'pipTranslate',\r\n    'pipSession',\r\n    'pipTransaction',\r\n    'pipRouting',\r\n    'pipFormat',\r\n    'pipTimer',\r\n    'pipScroll',\r\n    'pipTags',\r\n    'pipCodes',\r\n    'pipSystemInfo',\r\n    'pipPageReset'\r\n]);\r\n\r\nexport * from './translate';\r\nexport * from './session';\r\nexport * from './transactions';\r\nexport * from './routing';\r\nexport * from './utilities';\r\n","export let StateVar: string = \"$state\";\r\nexport let PrevStateVar: string = \"$prevState\";\r\n\r\n// Run function to set CurrentState and PreviousState global variables\r\nfunction captureStateTranslations($rootScope: ng.IRootScopeService) {\r\n    \"ngInject\";\r\n\r\n    $rootScope.$on('$stateChangeSuccess',\r\n        (event, toState, toParams, fromState, fromParams) => {\r\n\r\n            let CurrentState = {\r\n                name: toState.name, \r\n                url: toState.url, \r\n                params: toParams\r\n            };\r\n\r\n            let PreviousState = {\r\n                name: fromState.name, \r\n                url: fromState.url, \r\n                params: fromParams\r\n            };\r\n        // Record current and previous state\r\n        $rootScope[StateVar] = CurrentState;\r\n        $rootScope[PrevStateVar] = PreviousState;            \r\n        }\r\n    );\r\n\r\n}\r\n\r\n// Decorator function to modify $state service by adding goBack and goBackAndSelect methods\r\nfunction decorateBackStateService($delegate: any, $window: ng.IWindowService, $rootScope: ng.IRootScopeService): any {\r\n    \"ngInject\";\r\n\r\n    $delegate.goBack = goBack;\r\n    $delegate.goBackAndSelect = goBackAndSelect;\r\n\r\n    return $delegate;\r\n    //////////////////////////////////////////////////\r\n\r\n    function goBack(): void {\r\n        $window.history.back()\r\n    }\r\n\r\n    function goBackAndSelect(params: any): void {\r\n        // todo: define end fix PreviousState\r\n        if (!!$rootScope[StateVar] && !!$rootScope[PrevStateVar]) {\r\n\r\n            let state = _.cloneDeep($rootScope[PrevStateVar]);\r\n\r\n            // Override selected parameters\r\n            state.params = _.extend(state.params, params);\r\n\r\n            $delegate.go(state.name, state.params);\r\n        } else {\r\n            $window.history.back();\r\n        }\r\n    }\r\n}\r\n\r\n// Config function to decorate $state service\r\nfunction addBackStateDecorator($provide) {\r\n    $provide.decorator('$state', decorateBackStateService);\r\n}\r\n\r\nangular\r\n    .module('pipRouting')\r\n    .config(addBackStateDecorator)\r\n    .run(captureStateTranslations);\r\n    ","export let RoutingVar: string = \"$routing\";\r\n\r\nfunction hookRoutingEvents(\r\n    $rootScope: ng.IRootScopeService,\r\n    $log: ng.ILogService,\r\n    $state: ng.ui.IStateService\r\n) {\r\n    \"ngInject\";\r\n\r\n    $rootScope.$on('$stateChangeStart',\r\n        (event, toState, toParams, fromState, fromParams) => {\r\n            $rootScope[RoutingVar] = true;\r\n        }\r\n    );\r\n\r\n    $rootScope.$on('$stateChangeSuccess',\r\n        (event, toState, toParams, fromState, fromParams) => {\r\n            // Unset routing variable to disable page transition\r\n            $rootScope[RoutingVar] = false;                \r\n        }\r\n    );\r\n\r\n    // Intercept route error\r\n    $rootScope.$on('$stateChangeError',\r\n        (event, toState, toParams, fromState, fromParams, error) => {\r\n            // Unset routing variable to disable page transition\r\n            $rootScope[RoutingVar] = false;\r\n\r\n            $log.error('Error while switching route to ' + toState.name);\r\n            $log.error(error);\r\n        }\r\n    );\r\n\r\n}\r\n\r\nangular\r\n    .module('pipRouting')\r\n    .run(hookRoutingEvents);\r\n    ","angular.module('pipRouting', ['ui.router']);\r\n\r\nimport './BackDecorator';\r\nimport './RoutingEvents';\r\n\r\nexport * from './BackDecorator';\r\nexport * from './RoutingEvents';\r\n","import { IIdentityService, IIdentityProvider } from './IIdentityService';\r\n\r\nexport let IdentityRootVar = \"$identity\";\r\nexport let IdentityChangedEvent = \"pipIdentityChanged\";\r\n\r\nclass IdentityService implements IIdentityService {\r\n    private _identity: any;\r\n    private _setRootVar: boolean;\r\n    private _rootScope: ng.IRootScopeService;\r\n    private _log: ng.ILogService;\r\n\r\n    public constructor(\r\n        setRootVar: boolean,\r\n        identity: any,\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService\r\n    ) {\r\n        this._setRootVar = setRootVar;\r\n        this._identity = identity;\r\n        this._rootScope = $rootScope;\r\n        this._log = $log;\r\n\r\n        this.setRootVar();\r\n    }\r\n\r\n    private setRootVar(): void {\r\n        if (this._setRootVar)\r\n            this._rootScope[IdentityRootVar] = this._identity;\r\n    }\r\n\r\n    public get identity(): any {\r\n        return this._identity;\r\n    }\r\n\r\n    public set identity(value: any) {\r\n        this._identity = value;\r\n        this.setRootVar();\r\n        this._rootScope.$emit(IdentityChangedEvent, this._identity);\r\n\r\n        let identity: any = value || {};\r\n        this._log.debug(\"Changed identity to \" + JSON.stringify(identity));\r\n    }\r\n}\r\n\r\nclass IdentityProvider implements IdentityProvider {\r\n    private _setRootVar = true;\r\n    private _identity: any = null;\r\n    private _service: IdentityService = null;\r\n\r\n    public constructor() { }\r\n\r\n    public get setRootVar(): boolean {\r\n        return this._setRootVar;  \r\n    }\r\n\r\n    public set setRootVar(value: boolean) {\r\n        this._setRootVar = !!value;\r\n    }\r\n\r\n    public get identity(): any {\r\n        return this._identity;  \r\n    }\r\n\r\n    public set identity(value: any) {\r\n        this._identity = value;\r\n    }\r\n\r\n    public $get(\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService\r\n    ): any {\r\n        \"ngInject\";\r\n\r\n        if (this._service == null)\r\n            this._service = new IdentityService(this._setRootVar, this._identity, $rootScope, $log);\r\n\r\n        return this._service;\r\n    }\r\n\r\n}\r\n\r\nangular\r\n    .module('pipSession')\r\n    .provider('pipIdentity', IdentityProvider);\r\n","import { ISessionService, ISessionProvider } from './ISessionService';\r\n\r\nexport const SessionRootVar = \"$session\";\r\nexport const SessionOpenedEvent = \"pipSessionOpened\";\r\nexport const SessionClosedEvent = \"pipSessionClosed\";\r\n\r\nlet async = require('async');\r\n\r\nclass SessionService implements ISessionService {\r\n    private _setRootVar: boolean;\r\n    private _session: any;\r\n    private _rootScope: ng.IRootScopeService;\r\n    private _log: ng.ILogService;\r\n    private listeners: any = {};\r\n    private notifyError: boolean = false;\r\n\r\n    public constructor(\r\n        setRootVar: boolean,\r\n        session: any,\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService\r\n    ) {\r\n        this._setRootVar = setRootVar;\r\n        this._session = session;\r\n        this._rootScope = $rootScope;\r\n        this._log = $log;\r\n\r\n        this.setRootVar();\r\n    }\r\n\r\n    private notifyListeners(type: string, successCallback: (error?: any, result?: any) => void): void {\r\n        if (!type){  \r\n            throw new Error(\"Event object missing 'type' property.\");\r\n        }\r\n\r\n        if (this.listeners[type] instanceof Array){\r\n            async.each(\r\n                this.listeners[type], \r\n                (listener, callback) => {\r\n                listener(callback);\r\n            }, successCallback);\r\n        } else {\r\n            successCallback();\r\n        }\r\n    }\r\n\r\n    private notifyOpenListeners(callback: (error?: any, result?: any) => void): void {\r\n        this.notifyListeners('open', (error: any, result: any) => {\r\n            if (!error) {\r\n                callback(null, result);\r\n            } else {\r\n                // reset session\r\n                // this._session = null;\r\n                this._log.error(error);\r\n                callback(error);\r\n                // throw new Error('Session open error:');\r\n            }\r\n        });\r\n    }\r\n\r\n    private notifyCloseListeners(callback: (error?: any, result?: any) => void): void {\r\n        this.notifyListeners('close', (error: any, result: any) => {\r\n            if (!error) {\r\n                callback(null, result);\r\n            } else {\r\n                this._log.error(error);\r\n                callback(error);\r\n                // throw new Error('Session close error:');\r\n            }\r\n        });\r\n    }\r\n\r\n    private setRootVar(): void {\r\n        if (this._setRootVar)\r\n            this._rootScope[SessionRootVar] = this._session;\r\n    }\r\n\r\n    private start(session: any): void {\r\n        this.setRootVar();\r\n        this._rootScope.$emit(SessionOpenedEvent, session);\r\n        this._log.debug(\"Opened session \" + session);\r\n    }\r\n\r\n    private stop(): void {\r\n        let oldSession = this._session;\r\n\r\n        this._session = null;\r\n        this.setRootVar();\r\n        this._rootScope.$emit(SessionClosedEvent, oldSession);\r\n\r\n        this._log.debug(\"Closed session \" + oldSession);\r\n    }\r\n\r\n    private addListener(type: string, listener: any): void {\r\n        if (typeof this.listeners[type] == \"undefined\") {\r\n            this.listeners[type] = [];\r\n        }\r\n\r\n        this.listeners[type].push(listener);\r\n    }\r\n\r\n    private removeListener(type: string, listener: any): void {\r\n        if (this.listeners[type] instanceof Array) {\r\n            var listeners = this.listeners[type];\r\n            for (var i = 0, len = listeners.length; i < len; i++) {\r\n                if (listeners[i] === listener) {\r\n                    listeners.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public addOpenListener(listener: any): void {\r\n        this.addListener('open', listener);\r\n    }\r\n\r\n    public addCloseListener(listener: any): void {\r\n        this.addListener('close', listener);\r\n    }\r\n\r\n    public removeOpenListener(listener: any): void {\r\n        this.removeListener('open', listener);\r\n    }\r\n\r\n    public removeCloseListener(listener: any): void {\r\n        this.removeListener('close', listener);\r\n    }\r\n\r\n    public get session(): any {\r\n        return this._session;\r\n    }\r\n\r\n    public isOpened(): boolean {\r\n        return this._session != null;\r\n    }\r\n\r\n    public open(session: any) {\r\n        if (session == null)\r\n            throw new Error(\"Session cannot be null\");\r\n\r\n        this._session = session;\r\n\r\n        this.notifyOpenListeners((error?: any, result?: any) => {\r\n            if (!error) {\r\n                this.start(session);\r\n            } else {\r\n                this.stop();\r\n            }\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        if (this.session == null) { return }\r\n\r\n        this.notifyCloseListeners((error?: any, result?: any) => {\r\n            if (!error) this.stop();\r\n        });\r\n    }\r\n}\r\n\r\nclass SessionProvider implements ISessionProvider {\r\n    private _setRootVar = true;\r\n    private _session: any = null;\r\n    private _service: SessionService = null;\r\n\r\n    public constructor() { }\r\n\r\n    public get setRootVar(): boolean {\r\n        return this._setRootVar;\r\n    }\r\n\r\n    public set setRootVar(value: boolean) {\r\n        this._setRootVar = !!value;\r\n    }\r\n\r\n    public get session(): any {\r\n        return this._session;\r\n    }\r\n\r\n    public set session(value: any) {\r\n        this._session = value;\r\n    }\r\n\r\n    public $get(\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService\r\n    ): any {\r\n        \"ngInject\";\r\n\r\n        if (this._service == null)\r\n            this._service = new SessionService(this._setRootVar, this._session, $rootScope, $log);\r\n\r\n        return this._service;\r\n    }\r\n}\r\n\r\nangular\r\n    .module('pipSession')\r\n    .provider('pipSession', SessionProvider); \r\n","angular.module('pipSession', []);\r\n\r\nimport './IdentityService';\r\nimport './SessionService';\r\n\r\nexport * from './IIdentity';\r\nexport * from './IIdentityService';\r\nexport * from './IdentityService';\r\n\r\nexport * from './ISessionService';\r\nexport * from './SessionService';\r\n","import { TransactionError } from './TransactionError'\r\n\r\nexport class Transaction {\r\n    private _scope: string = null;\r\n    private _id: string = null;\r\n    private _operation: string = null;\r\n    private _error: TransactionError = new TransactionError();\r\n    private _progress: number = 0;\r\n\r\n    public constructor(scope: string) {\r\n        this._scope = scope;\r\n    }\r\n\r\n    public get scope(): string {\r\n        return this._scope;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    public get operation(): string {\r\n        return this._operation;\r\n    }\r\n\r\n    public get progress(): number {\r\n        return this._progress;\r\n    }\r\n\r\n    public get error(): TransactionError {\r\n        return this._error;\r\n    }\r\n\r\n    public get errorMessage(): string {\r\n        return this._error.message;\r\n    }\r\n\r\n    public reset(): void {\r\n        this._id = null;\r\n        this._operation = null;\r\n        this._progress = 0;\r\n        this._error.reset();\r\n    }\r\n\r\n    public busy(): boolean {\r\n        return this._id != null;\r\n    }\r\n\r\n    public failed(): boolean {\r\n        return !this._error.empty();\r\n    }\r\n\r\n    public aborted(id: string): boolean {\r\n        return this._id != id;\r\n    }\r\n\r\n    public begin(operation: string): string {\r\n        // Transaction is already running\r\n        if (this._id != null) return null;\r\n\r\n        this._id = new Date().getTime().toString();\r\n        this._operation = operation || 'PROCESSING'\r\n        this._error.reset();\r\n\r\n        return this._id;\r\n    }\r\n\r\n    public update(progress: number): void {\r\n        this._progress = Math.max(progress, 100);\r\n    }\r\n\r\n    public abort(): void {\r\n        this._id = null;\r\n        this._error.reset();\r\n    }\r\n\r\n    public end(error?: any): void {\r\n        this._error.decode(error);\r\n        this._id = null;\r\n    }\r\n}\r\n","export class TransactionError {\r\n    public code: string;\r\n    public message: string;\r\n    public details: any;\r\n    public cause: string;\r\n    public stack_trace: string;\r\n\r\n    public constructor(error?: any) {\r\n        if (error != null)\r\n            this.decode(error);\r\n    }\r\n\r\n    public reset(): void {\r\n        this.code = null;\r\n        this.message = null;\r\n        this.details = null;\r\n        this.cause = null;\r\n        this.stack_trace = null;\r\n    }\r\n\r\n    public empty(): boolean {\r\n        return this.message = null && this.code == null;\r\n    }\r\n\r\n    public decode(error: any): void {\r\n        this.reset();\r\n\r\n        if (error == null) return;\r\n\r\n        // Process regular messages\r\n        if (error.message) {\r\n            this.message = error.message;\r\n        }\r\n\r\n        // Process server application errors\r\n        if (error.data) {\r\n            if (error.data.code) { \r\n                // process server error codes here\r\n                this.message = this.message || 'ERROR_' + error.data.code;\r\n                this.code = this.code || error.data.code;\r\n            }\r\n\r\n            if (error.data.message) {\r\n                this.message = this.message || error.data.message;\r\n            }\r\n\r\n            this.message = this.message || error.data;\r\n            this.details = this.details || error.data;\r\n\r\n            this.cause = error.data.cause;\r\n            this.stack_trace = error.data.stack_trace;\r\n            this.details = error.data.details;            \r\n        }\r\n\r\n        // Process standard HTTP errors\r\n        if (error.statusText) {\r\n            this.message = this.message || error.statusText;\r\n        }\r\n        if (error.status) {\r\n            this.message = this.message || 'ERROR_' + error.status;\r\n            this.code = this.code || error.status;\r\n        }\r\n        \r\n        this.message = this.message || error;\r\n        this.details = this.details || error;\r\n    }\r\n}\r\n","import { Transaction } from './Transaction';\r\nimport { ITransactionService } from './ITransactionService';\r\n\r\nclass TransactionService implements ITransactionService {\r\n    private _transactions: Transaction = <Transaction>{};\r\n\r\n    public constructor() {}\r\n\r\n    public create(scope?: string): Transaction {\r\n        let transaction: Transaction = new Transaction(scope);\r\n        \r\n        if (scope != null)\r\n            this._transactions[scope] = transaction;\r\n\r\n        return transaction;\r\n    }\r\n\r\n    public get(scope?: string): Transaction {\r\n        let transaction: Transaction = scope != null ? <Transaction>this._transactions[scope] : null;\r\n\r\n        if (transaction == null) {\r\n            transaction = new Transaction(scope);\r\n            if (scope != null)\r\n                this._transactions[scope] = transaction;\r\n        }\r\n\r\n        return transaction;\r\n    }\r\n}\r\n\r\nangular\r\n    .module('pipTransaction')\r\n    .service('pipTransaction', TransactionService);\r\n","import { ITranslateService } from '../translate/ITranslateService';\r\n\r\nfunction configureTransactionStrings($injector: ng.auto.IInjectorService) {\r\n    \"ngInject\";\r\n\r\n    let pipTranslate: ITranslateService = $injector.has('pipTranslateProvider') \r\n        ? <ITranslateService>$injector.get('pipTranslateProvider') : null;\r\n\r\n    if (pipTranslate) {\r\n        pipTranslate.setTranslations('en', {\r\n            'ENTERING': 'Entering...',\r\n            'PROCESSING': 'Processing...',\r\n            'LOADING': 'Loading...',\r\n            'SAVING': 'Saving...'\r\n        });\r\n\r\n        pipTranslate.setTranslations('ru', {\r\n            'ENTERING': '  ...',\r\n            'PROCESSING': '...',\r\n            'LOADING': '...',\r\n            'SAVING': '...'\r\n        });   \r\n    }\r\n    \r\n}\r\n\r\nangular\r\n    .module('pipTransaction')\r\n    .config(configureTransactionStrings);\r\n","angular.module('pipTransaction', []);\r\n\r\nimport './TransactionStrings';\r\nimport './TransactionError';\r\nimport './Transaction';\r\nimport './TransactionService';\r\n\r\nexport * from './TransactionError';\r\nexport * from './Transaction';\r\nexport * from './ITransactionService';\r\n","import { ITranslateService } from '../translate/ITranslateService';\r\n\r\nfunction translateDirective(pipTranslate): ng.IDirective {\r\n    \"ngInject\";\r\n\r\n    return {\r\n        restrict: 'EA',\r\n        scope: {\r\n            key1: '@pipTranslate',\r\n            key2: '@key'\r\n        },\r\n        link: (scope: any, element: ng.IAugmentedJQuery, attrs: ng.IAttributes) => {\r\n            let key: string = scope.key1 || scope.key2;\r\n            let value: string = pipTranslate.translate(key);\r\n            element.text(value);\r\n        }\r\n    };\r\n}\r\n\r\nfunction translateHtmlDirective(pipTranslate: ITranslateService): ng.IDirective {\r\n    \"ngInject\";\r\n\r\n    return {\r\n        restrict: 'EA',\r\n        scope: {\r\n            key1: '@pipTranslateHtml',\r\n            key2: '@key'\r\n        },\r\n        link: (scope: any, element: ng.IAugmentedJQuery, attrs: ng.IAttributes) => {\r\n            let key: string = scope.key1 || scope.key2;\r\n            let value: string = pipTranslate.translate(key);\r\n            element.html(value);\r\n        }\r\n    };\r\n}\r\n\r\nangular\r\n    .module('pipTranslate')\r\n    .directive('pipTranslate', translateDirective)\r\n    .directive('pipTranslateHtml', translateHtmlDirective);\r\n","import { ITranslateService } from './ITranslateService';\r\n\r\nfunction translateFilter(pipTranslate: ITranslateService) {\r\n    \"ngInject\";\r\n\r\n    return function (key: string) {\r\n        return pipTranslate.translate(key) || key;\r\n    }\r\n}\r\n\r\nfunction optionalTranslateFilter($injector: ng.auto.IInjectorService) {\r\n    \"ngInject\";\r\n\r\n    let pipTranslate: ITranslateService = $injector.has('pipTranslate') \r\n        ? <ITranslateService>$injector.get('pipTranslate') : null;\r\n\r\n    return function (key: string) {\r\n        return pipTranslate  ? pipTranslate.translate(key) || key : key;\r\n    }\r\n}\r\n\r\nangular\r\n    .module('pipTranslate')\r\n    .filter('translate', translateFilter);\r\n","export class Translation {\r\n    protected _language: string = 'en';\r\n    protected _translations = {\r\n        en: {\r\n            'en': 'English',\r\n            'ru': 'Russian',\r\n            'es': 'Spanish',\r\n            'pt': 'Portuguese',\r\n            'de': 'German',\r\n            'fr': 'French'\r\n        },\r\n        ru: {\r\n            'en': '',\r\n            'ru': '',\r\n            'es': '',\r\n            'pt': '',\r\n            'de': '',\r\n            'fr': ''\r\n        }\r\n    };\r\n\r\n    public constructor() {}\r\n\r\n    public get language(): string { return this._language; }\r\n    public set language(value: string) { this._language = value; }\r\n\r\n    public use(language: string): string {\r\n        if (language != null)\r\n            this._language = language;\r\n        return this._language;\r\n    }\r\n\r\n    // Set translation strings for specific language\r\n    public setTranslations(language: string, translations: any): void {\r\n        let map = this._translations[language] || {};\r\n        this._translations[language] = _.extend(map, translations);\r\n    }\r\n\r\n    // Yet another method to set translation strings for specific language\r\n    public translations(language: string, translations: any): void {\r\n        this.setTranslations(language, translations);\r\n    }\r\n\r\n    // Translate a string by key using set language\r\n    public translate(key: string): string {\r\n        if (_.isNull(key) || _.isUndefined(key)) return '';\r\n\r\n        let translations = this._translations[this._language] || {};\r\n        return translations[key] || key;\r\n    }\r\n\r\n    // Translate an array of strings\r\n    public translateArray(keys: string[]): string[] {\r\n        if (_.isNull(keys) || keys.length == 0) return [];\r\n\r\n        let values: string[] = [];\r\n        let translations = this._translations[this._language] || {};\r\n\r\n        _.each(keys, function (k: string) {\r\n            let key = k || '';\r\n            values.push(translations[key] || key);\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    // Translate an array of strings into array of objects (set)\r\n    public translateSet(keys: string[], keyProp: string, valueProp: string): any[] {\r\n        if (_.isNull(keys) || keys.length == 0) return [];\r\n\r\n        keyProp = keyProp || 'id';\r\n        valueProp = valueProp || 'name';\r\n\r\n        let values: any[] = [];\r\n        let translations = this._translations[this._language] || {};\r\n\r\n        _.each(keys, function (key: string) {\r\n            let value: any = {};\r\n            key = key || '';\r\n\r\n            value[keyProp] = key;\r\n            value[valueProp] = translations[key] || key;\r\n\r\n            values.push(value);\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    // Translate a collection of objects\r\n    public translateObjects(items: any[], keyProp: string, valueProp: string): any[] {\r\n        if (_.isNull(items) || items.length == 0) return [];\r\n\r\n        keyProp = keyProp || 'name';\r\n        valueProp = valueProp || 'nameLocal';\r\n\r\n        let translations = this._translations[this._language] || {};\r\n\r\n        _.each(items, function (item: any) {\r\n            let key = item[keyProp] || '';\r\n\r\n            item[valueProp] = translations[key] || key;\r\n        });\r\n\r\n        return items;\r\n    }\r\n\r\n    // Translate a string by key  with prefix using set language todo\r\n    public translateWithPrefix(prefix: string, key: string) {\r\n        prefix = prefix ? prefix + '_' : '';\r\n        key = (prefix + key).replace(/ /g, '_').toUpperCase();\r\n        if (key == null) return '';\r\n        let translations = this._translations[this._language] || {};\r\n        return translations[key] || key;\r\n    };\r\n\r\n    public translateSetWithPrefix(prefix: string, keys: string[], keyProp: string, valueProp: string) {\r\n        if (_.isNull(keys) || keys.length == 0) return [];\r\n\r\n        prefix = prefix ? prefix.replace(/ /g, '_').toUpperCase() : '';\r\n        keyProp = keyProp || 'id';\r\n        valueProp = valueProp || 'name';\r\n\r\n        let values = [];\r\n        let translations = this._translations[this._language] || {};\r\n\r\n        _.each(keys, function (key: string) {\r\n            let value: any = {}; \r\n            key = key || '';\r\n\r\n            value[keyProp] = key;\r\n            value[valueProp] = translations[prefix + '_' + key] || key;\r\n\r\n            values.push(value);\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    // Translate an array of strings, apply uppercase and replace ' ' => '_'\r\n    public translateSetWithPrefix2(prefix: string, keys: string[], keyProp: string, valueProp: string) {\r\n        if (_.isNull(keys) || keys.length == 0) return [];\r\n\r\n        keyProp = keyProp || 'id';\r\n        valueProp = valueProp || 'name';\r\n        prefix = prefix ? prefix.replace(/ /g, '_').toUpperCase() + '_': '';\r\n\r\n        let values = [];\r\n        let translations = this._translations[this._language] || {};\r\n\r\n        _.each(keys, function (key: string) {\r\n            let value: any = {};\r\n            key = key || '';\r\n\r\n            value[keyProp] = key;\r\n            value[valueProp] = translations[prefix + key.replace(/ /g, '_').toUpperCase()]\r\n                || (prefix + key.replace(/ /g, '_').toUpperCase());\r\n\r\n            values.push(value);\r\n        });\r\n\r\n        return values;\r\n    }\r\n}\r\n","import { Translation } from './Translation';\r\nimport { ResetPageEvent } from '../utilities/PageResetService';\r\nimport { ITranslateService, ITranslateProvider } from './ITranslateService';\r\n\r\nexport let LanguageRootVar = \"$language\";\r\nexport let LanguageChangedEvent = \"pipLanguageChanged\";    \r\n\r\nclass TranslateService implements ITranslateService {\r\n    private _translation: Translation;\r\n    private _setRootVar: boolean;\r\n    private _persist: boolean;\r\n    private _rootScope: ng.IRootScopeService;\r\n    private _log: ng.ILogService;\r\n    private _window: ng.IWindowService;\r\n    private _mdDateLocale: angular.material.IDateLocaleProvider;\r\n\r\n    public constructor(\r\n        translation: Translation,\r\n        setRootVar: boolean,\r\n        persist: boolean,\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService,\r\n        $window: ng.IWindowService,\r\n        $mdDateLocale: angular.material.IDateLocaleProvider,\r\n    ) {\r\n        this._setRootVar = setRootVar;\r\n        this._persist = persist;\r\n        this._translation = translation;\r\n        this._rootScope = $rootScope;\r\n        this._log = $log;\r\n        this._window = $window;\r\n        this._mdDateLocale = $mdDateLocale;\r\n\r\n        if (this._persist && this._window.localStorage) {\r\n            this._translation.language = this._window.localStorage.getItem('language') || this._translation.language;\r\n            this.changeLocale(this._translation.language);\r\n        }\r\n        this._log.debug(\"Set language to \" + this._translation.language);\r\n\r\n        this.save();\r\n    }\r\n\r\n    private changeLocale(locale: string) {\r\n        if (!locale) return;\r\n\r\n        // var localeDate: moment.MomentLanguageData;\r\n        var localeDate: any;\r\n\r\n        moment.locale(locale);\r\n        localeDate = moment.localeData();\r\n\r\n        this._mdDateLocale.months = angular.isArray(localeDate._months) ? localeDate._months : localeDate._months.format;\r\n        this._mdDateLocale.shortMonths = angular.isArray(localeDate._monthsShort) ? localeDate._monthsShort : localeDate._monthsShort.format;\r\n        this._mdDateLocale.days = angular.isArray(localeDate._weekdays) ? localeDate._weekdays : localeDate._weekdays.format;\r\n        this._mdDateLocale.shortDays = localeDate._weekdaysMin;\r\n        this._mdDateLocale.firstDayOfWeek = localeDate._week.dow;\r\n    }\r\n\r\n    private save(): void {\r\n        if (this._setRootVar)\r\n            this._rootScope[LanguageRootVar] = this._translation.language;\r\n\r\n        if (this._persist && this._window.localStorage != null)\r\n            this._window.localStorage.setItem('language', this._translation.language);\r\n    }\r\n\r\n    public get language(): string {\r\n        return this._translation.language;\r\n    }\r\n\r\n    public set language(value: string) {\r\n        if (value != this._translation.language) {\r\n            this._translation.language = value;\r\n            \r\n            this._log.debug(\"Changing language to \" + value);\r\n\r\n            this.changeLocale(this._translation.language);\r\n            this.save();   \r\n\r\n            this._rootScope.$emit(LanguageChangedEvent, value);\r\n            this._rootScope.$emit(ResetPageEvent);\r\n        }\r\n    }\r\n\r\n    public use(language: string): string {\r\n        if (language != null)\r\n            this.language = language;\r\n        return this.language;\r\n    }\r\n\r\n    public setTranslations(language: string, translations: any): void {\r\n        return this._translation.setTranslations(language, translations);\r\n    }\r\n\r\n    public translations(language: string, translations: any): void {\r\n        return this._translation.setTranslations(language, translations);\r\n    }\r\n\r\n    public translate(key: string): string {\r\n        return this._translation.translate(key);\r\n    }\r\n\r\n    public translateArray(keys: string[]): string[] {\r\n        return this._translation.translateArray(keys);\r\n    }\r\n    \r\n    public translateSet(keys: string[], keyProp: string, valueProp: string): any[] {\r\n        return this._translation.translateSet(keys, keyProp, valueProp);\r\n    }\r\n\r\n    public translateObjects(items: any[], keyProp: string, valueProp: string): any[] {\r\n        return this._translation.translateObjects(items, keyProp, valueProp);\r\n    }\r\n\r\n    public translateWithPrefix(prefix: string, key: string) {\r\n        return this._translation.translateWithPrefix(prefix, key);\r\n    }\r\n\r\n    public translateSetWithPrefix(prefix: string, keys: string[], keyProp: string, valueProp: string) {\r\n        return this._translation.translateSetWithPrefix(prefix, keys, keyProp, valueProp);\r\n    }\r\n\r\n    public translateSetWithPrefix2(prefix: string, keys: string[], keyProp: string, valueProp: string) {\r\n        return this._translation.translateSetWithPrefix2(prefix, keys, keyProp, valueProp);\r\n    }\r\n}\r\n\r\nclass TranslateProvider extends Translation implements ITranslateProvider {\r\n    private _translation: Translation;\r\n    private _setRootVar: boolean = true;\r\n    private _persist: boolean = true;\r\n    private _service: TranslateService;\r\n    \r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    public get setRootVar(): boolean {\r\n        return this._setRootVar;  \r\n    }\r\n\r\n    public set setRootVar(value: boolean) {\r\n        this._setRootVar = !!value;\r\n    }\r\n\r\n    public get persist(): boolean {\r\n        return this._persist;  \r\n    }\r\n\r\n    public set persist(value: boolean) {\r\n        this._persist = !!value;\r\n    }\r\n\r\n    public $get(\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService, \r\n        $window: ng.IWindowService,\r\n        $mdDateLocale: angular.material.IDateLocaleProvider\r\n    ): any {\r\n        \"ngInject\";\r\n\r\n        if (this._service == null) \r\n            this._service = new TranslateService(this, this._setRootVar, this._persist, $rootScope, $log, $window, $mdDateLocale);\r\n\r\n        return this._service;\r\n    }\r\n}\r\n\r\nfunction initTranslate(pipTranslate: ITranslateService) {\r\n    pipTranslate.language;\r\n}\r\n\r\nangular\r\n    .module('pipTranslate')\r\n    .provider('pipTranslate', TranslateProvider)\r\n    .run(initTranslate);\r\n","angular.module('pipTranslate', []);\r\n\r\nimport './Translation';\r\nimport './TranslateService';\r\nimport './TranslateFilter';\r\nimport './TranslateDirective';\r\n\r\nexport * from './Translation';\r\nexport * from './ITranslateService';\r\nexport * from './TranslateService';\r\n","import { ICodes } from './ICodes';\r\n\r\nclass Codes implements ICodes {\r\n    // Simple version of string hashcode\r\n    public hash(value: string): number {\r\n        if (value == null) return 0;\r\n        \r\n        let result: number = 0;\r\n        for (let i = 0; i < value.length; i++)\r\n            result += value.charCodeAt(i);\r\n\r\n        return result;\r\n    }\r\n\r\n    // Generates random big number for verification codes\r\n    public verification(): string {\r\n        return Math.random().toString(36).substr(2, 10).toUpperCase(); // remove `0.`\r\n    }\r\n}\r\n\r\nangular\r\n    .module('pipCodes', [])\r\n    .service('pipCodes', Codes);\r\n","import { IFormat } from './IFormat';\r\n\r\nclass Format implements IFormat {\r\n    // Cached for parsed formats\r\n    private cache = {};\r\n\r\n    // Creates a sample line from a text\r\n    public sample(value: string, maxLength: number): string {\r\n        if (!value || value == '') {\r\n            return '';\r\n        }\r\n\r\n        var length: number = value.indexOf('\\n');\r\n        length = length >= 0 ? length : value.length;\r\n        length = length < maxLength ? value.length : maxLength;\r\n\r\n        return value.substring(0, length);\r\n    }\r\n\r\n    private strRepeat(str: string, qty: number): string {\r\n        if (qty < 1) { \r\n            return '';\r\n        }\r\n        var result: string = '';\r\n        while (qty > 0) {\r\n            if (qty & 1) result += str;\r\n            qty >>= 1, str += str;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private getType(variable): string {\r\n        return toString.call(variable).slice(8, -1).toLowerCase();\r\n    }\r\n\r\n    private parseFormat(fmt: string): any {\r\n        let _fmt: string = fmt, match = [], parse_tree = [], arg_names: number = 0;\r\n        while (_fmt) {\r\n            if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\r\n                parse_tree.push(match[0]);\r\n            }\r\n            else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\r\n                parse_tree.push('%');\r\n            }\r\n            else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\r\n                if (match[2]) {\r\n                    arg_names |= 1;\r\n                    let field_list: string[] = [], replacement_field: string = match[2], field_match: string[] = [];\r\n                    if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\r\n                        field_list.push(field_match[1]);\r\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\r\n                            if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\r\n                                field_list.push(field_match[1]);\r\n                            }\r\n                            else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\r\n                                field_list.push(field_match[1]);\r\n                            }\r\n                            else {\r\n                                throw new Error('Unknown error');\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error('Unknown error');\r\n                    }\r\n                    match[2] = field_list;\r\n                }\r\n                else {\r\n                    arg_names |= 2;\r\n                }\r\n                if (arg_names === 3) {\r\n                    throw new Error('Mixing positional and named placeholders is not (yet) supported');\r\n                }\r\n                parse_tree.push(match);\r\n            }\r\n            else {\r\n                throw new Error('Unknown error');\r\n            }\r\n            _fmt = _fmt.substring(match[0].length);\r\n        }\r\n        return parse_tree;\r\n    }\r\n\r\n    private format(parse_tree: any, argv: any): string {\r\n        let cursor: number = 0; \r\n        let tree_length: number = parse_tree.length; \r\n        let output = [];\r\n\r\n        for (let i = 0; i < tree_length; i++) {\r\n            let node_type = this.getType(parse_tree[i]);\r\n            if (node_type === 'string') {\r\n                output.push(parse_tree[i]);\r\n            }\r\n            else if (node_type === 'array') {\r\n                let match = parse_tree[i]; // convenience purposes only\r\n                let arg: any;\r\n                if (match[2]) { // keyword argument\r\n                    arg = argv[cursor];\r\n                    for (let k = 0; k < match[2].length; k++) {\r\n                        if (!arg.hasOwnProperty(match[2][k])) {\r\n                            throw new Error(this.sprintf('Property \"%s\" does not exist', match[2][k]));\r\n                        }\r\n                        arg = arg[match[2][k]];\r\n                    }\r\n                } else if (match[1]) { // positional argument (explicit)\r\n                    arg = argv[match[1]];\r\n                }\r\n                else { // positional argument (implicit)\r\n                    arg = argv[cursor++];\r\n                }\r\n\r\n                if (/[^s]/.test(match[8]) && (this.getType(arg) != 'number')) {\r\n                    throw new Error(this.sprintf('Expecting number but found %s', this.getType(arg)));\r\n                }\r\n                switch (match[8]) {\r\n                    case 'b': arg = arg.toString(2); break;\r\n                    case 'c': arg = String.fromCharCode(arg); break;\r\n                    case 'd': arg = parseInt(arg, 10); break;\r\n                    case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\r\n                    case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\r\n                    case 'o': arg = arg.toString(8); break;\r\n                    case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\r\n                    case 'u': arg = Math.abs(arg); break;\r\n                    case 'x': arg = arg.toString(16); break;\r\n                    case 'X': arg = arg.toString(16).toUpperCase(); break;\r\n                }\r\n                arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);                \r\n                let pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\r\n                let pad_length = match[6] - String(arg).length;\r\n                let pad = match[6] ? this.strRepeat(pad_character, pad_length) : '';\r\n                output.push(match[5] ? arg + pad : pad + arg);\r\n            }\r\n        }\r\n        return output.join('');\r\n    }\r\n    \r\n    public sprintf(message: string, ...args: any[]): string {\r\n        if (!this.cache.hasOwnProperty(message))\r\n            this.cache[message] = this.parseFormat(message);\r\n\r\n        return this.format(this.cache[message], args);\r\n    }\r\n\r\n    public filterToString(filter: any): string {\r\n        if (filter == null) return null;\r\n        let result = ''; \r\n\r\n        for (let key in filter) {\r\n            if (result.length > 0)\r\n                result += ';';\r\n\r\n            let value = filter[key];\r\n            if (value != null)\r\n                result += key + '=' + value\r\n            else\r\n                result += key\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public arrayToString(array: string[]): string {\r\n        let result = ''; \r\n\r\n        if (array == null || array.length == 0)\r\n            return result;\r\n\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (result.length > 0)\r\n                result += ',';\r\n            result += array[i]\r\n        }\r\n\r\n        return result;\r\n    }    \r\n\r\n    public enumToArray(obj: any): any[] {\r\n        let result: any[] = [];\r\n        let key;\r\n\r\n        for (key in obj)\r\n            if (obj.hasOwnProperty(key))\r\n                result.push(obj[key]);\r\n\r\n        return result;\r\n    };    \r\n}\r\n\r\n\r\nangular\r\n    .module('pipFormat', [])\r\n    .service('pipFormat', Format);\r\n","import { IPageResetService } from './IPageResetService';\r\n\r\n\r\nexport let ResetPageEvent: string = \"pipResetPage\";\r\nexport let ResetAreaEvent: string = \"pipResetArea\";\r\n\r\nexport let ResetRootVar: string = \"$reset\";\r\nexport let ResetAreaRootVar: string = \"$resetArea\";\r\n\r\n\r\nclass PageResetService implements IPageResetService {\r\n    private _rootScope: ng.IRootScopeService;\r\n    private _log: ng.ILogService;\r\n    private _timeout: ng.ITimeoutService;\r\n\r\n    public constructor(\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService, \r\n        $timeout: ng.ITimeoutService\r\n    ) {\r\n        this._rootScope = $rootScope;\r\n        this._log = $log;\r\n        this._timeout = $timeout;\r\n\r\n        $rootScope[ResetRootVar] = false;\r\n        $rootScope[ResetAreaRootVar] = null;\r\n    }\r\n\r\n    public reset(): void {\r\n        this._log.debug(\"Resetting the entire page\");\r\n        this.performReset(null);\r\n    }\r\n\r\n    public resetArea(area: string): void {\r\n        this._log.debug(\"Resetting the area \" + area);\r\n        this.performReset(area);\r\n    }\r\n\r\n    private performReset(area?: string): void {\r\n        this._rootScope[ResetRootVar] = area == null;\r\n        this._rootScope[ResetAreaRootVar] = area;\r\n\r\n        this._timeout(() => {\r\n            this._rootScope[ResetRootVar] = false;\r\n            this._rootScope[ResetAreaRootVar] = null;\r\n        }, 0);\r\n    }\r\n}\r\n\r\n\r\nfunction hookResetEvents(\r\n    $rootScope: ng.IRootScopeService, \r\n    pipPageReset: IPageResetService\r\n) {\r\n    $rootScope.$on(ResetPageEvent, () => { pipPageReset.reset(); });\r\n    $rootScope.$on(ResetAreaEvent, (event, area) => { pipPageReset.resetArea(area); });\r\n}\r\n\r\n\r\nangular.module('pipPageReset', [])\r\n    .service('pipPageReset', PageResetService)\r\n    .run(hookResetEvents);\r\n","import { IScrollService } from './IScrollService';\r\n\r\n\r\nclass ScrollService implements IScrollService {\r\n\r\n    public scrollTo(parentElement, childElement, animationDuration): void {\r\n        if (!parentElement || !childElement) return;\r\n        if (animationDuration == undefined) animationDuration = 300;\r\n\r\n        setTimeout(function () {\r\n            if (!$(childElement).position()) return;\r\n            var modDiff= Math.abs($(parentElement).scrollTop() - $(childElement).position().top);\r\n            if (modDiff < 20) return;\r\n            var scrollTo = $(parentElement).scrollTop() + ($(childElement).position().top - 20);\r\n            if (animationDuration > 0)\r\n                $(parentElement).animate({\r\n                    scrollTop: scrollTo + 'px'\r\n                }, animationDuration);\r\n        }, 100);\r\n    }\r\n\r\n}\r\n\r\n\r\nangular\r\n    .module('pipScroll', [])\r\n    .service('pipScroll', ScrollService);\r\n","import { ISystemInfo } from './ISystemInfo';\r\n\r\n\r\nclass SystemInfo implements ISystemInfo {\r\n    private _window: ng.IWindowService;\r\n\r\n    public constructor($window: ng.IWindowService) {\r\n        \"ngInject\";\r\n\r\n        this._window = $window;\r\n    }\r\n\r\n    // todo add support for iPhone\r\n    public get browserName(): string {\r\n        let ua = this._window.navigator.userAgent;\r\n\r\n        if (ua.search(/Edge/) > -1) return \"edge\";\r\n        if (ua.search(/MSIE/) > -1) return \"ie\";\r\n        if (ua.search(/Trident/) > -1) return \"ie\";\r\n        if (ua.search(/Firefox/) > -1) return \"firefox\";\r\n        if (ua.search(/Opera/) > -1) return \"opera\";\r\n        if (ua.search(/OPR/) > -1) return \"opera\";\r\n        if (ua.search(/YaBrowser/) > -1) return \"yabrowser\";\r\n        if (ua.search(/Chrome/) > -1) return \"chrome\";\r\n        if (ua.search(/Safari/) > -1) return \"safari\";\r\n        if (ua.search(/Maxthon/) > -1) return \"maxthon\";\r\n        \r\n        return \"unknown\";\r\n    }\r\n\r\n    public get browserVersion(): string {\r\n        let version;\r\n        let ua = this._window.navigator.userAgent;\r\n        let browser = this.browserName;\r\n\r\n        switch (browser) {\r\n            case \"edge\":\r\n                version = (ua.split(\"Edge\")[1]) ? (ua.split(\"Edge\")[1]).split(\"/\")[1] : null;\r\n                break;\r\n            case \"ie\":\r\n                let subVersion = ua.split(\"MSIE \")[1] ? ua.split(\"MSIE \")[1] : ua.split(\"Trident/\")[1]\r\n                version = subVersion ? subVersion.split(\";\")[0] : null;\r\n                break;\r\n            case \"ie11\":\r\n                browser = \"ie\";\r\n                version = (ua.split(\"; rv:\")[1]) ? (ua.split(\"; rv:\")[1]).split(\")\")[0] : null;\r\n                break;\r\n            case \"firefox\":\r\n                version = ua.split(\"Firefox/\")[1];\r\n                break;\r\n            case \"opera\":\r\n                version = (ua.search(/Opera/) > -1) ? ua.split(\"Version/\")[1] : ua.split(\"OPR/\")[1];\r\n                break;\r\n            case \"yabrowser\":\r\n                version = (ua.split(\"YaBrowser/\")[1]) ? (ua.split(\"YaBrowser/\")[1]).split(\" \")[0] : null;\r\n                break;\r\n            case \"chrome\":\r\n                version = (ua.split(\"Chrome/\")[1]) ? (ua.split(\"Chrome/\")[1]).split(\" \")[0] : null;\r\n                break;\r\n            case \"safari\":\r\n                version = (ua.split(\"Safari/\")[1]) ? (ua.split(\"Safari/\")[1]).split(\" \")[0] : null;\r\n                break;\r\n            case \"maxthon\":\r\n                version = ua.split(\"Maxthon/\")[1];\r\n                break;\r\n        }\r\n\r\n        return version;\r\n    }\r\n    \r\n    public get platform(): string {\r\n        let ua = this._window.navigator.userAgent;\r\n\r\n        if (/iphone|ipad|ipod|android|blackberry|mini|windows\\sce|palm/i.test(ua.toLowerCase())) \r\n            return 'mobile';\r\n\r\n        return 'desktop';\r\n    }\r\n\r\n    public get os(): string {\r\n        let ua = this._window.navigator.userAgent;\r\n\r\n        try {\r\n            let osAll = (/(windows|mac|android|linux|blackberry|sunos|solaris|iphone)/.exec(ua.toLowerCase()) || [ua])[0].replace('sunos', 'solaris');\r\n            let osAndroid = (/(android)/.exec(ua.toLowerCase()) || '');\r\n            return osAndroid && (osAndroid == 'android' || (osAndroid[0] == 'android')) ? 'android' : osAll;\r\n        } catch (err) {\r\n            return 'unknown'\r\n        }\r\n    }\r\n\r\n    public isDesktop(): boolean {\r\n        return this.platform == 'desktop';\r\n    }\r\n\r\n    public isMobile(): boolean {\r\n        return this.platform == 'mobile';\r\n    }\r\n\r\n    // Todo: complete implementation\r\n    public isCordova(): boolean {\r\n        return false;\r\n    }\r\n\r\n    // Todo: Move to errors\r\n    public isSupported(supported?: any): boolean {\r\n        if (!supported) \r\n            supported = {\r\n                edge: 12,\r\n                ie: 11,\r\n                firefox: 43, //4, for testing\r\n                opera: 35,\r\n                chrome: 47,\r\n                safari: 600\r\n            };\r\n\r\n        let browser = this.browserName;\r\n        let version = this.browserVersion;\r\n        version = version.split(\".\")[0]\r\n\r\n        if (browser && supported[browser] && version >= supported[browser]) \r\n            return true;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\nangular\r\n    .module('pipSystemInfo', [])\r\n    .service('pipSystemInfo', SystemInfo);\r\n","import { ITags } from './ITags';\r\n\r\nclass Tags implements ITags {\r\n\r\n    public normalizeOne(tag: string): string {\r\n        return tag \r\n            ? _.trim(tag.replace(/(_|#)+/g, ' '))\r\n            : null;\r\n    }\r\n\r\n    public compressOne(tag: string): string {\r\n        return tag\r\n            ? tag.replace(/( |_|#)/g, '').toLowerCase()\r\n            : null;\r\n    }\r\n\r\n    public equal(tag1: string, tag2: string): boolean {\r\n        if (tag1 == null && tag2 == null)\r\n            return true;\r\n        if (tag1 == null || tag2 == null)\r\n            return false;\r\n        return this.compressOne(tag1) == this.compressOne(tag2);\r\n    }\r\n\r\n    public normalizeAll(tags: any): string[] {\r\n        if (_.isString(tags))\r\n            tags = tags.split(/( |,|;)+/);\r\n\r\n        tags = _.map(tags, (tag: string) => this.normalizeOne(tag));\r\n\r\n        return tags;\r\n    }\r\n\r\n    public compressAll(tags: any): string[] {\r\n        if (_.isString(tags))\r\n            tags = tags.split(/( |,|;)+/);\r\n\r\n        tags = _.map(tags, (tag: string) => this.compressOne(tag));\r\n\r\n        return tags;\r\n    }\r\n\r\n    public extract(entity: any, searchFields?: string[]): string[] {\r\n        let tags = this.normalizeAll(entity.tags);\r\n\r\n        _.each(searchFields, (field) => {\r\n            let text = entity[field] || '';\r\n\r\n            if (text != '') {\r\n                let hashTags = text.match(/#\\w+/g);\r\n                tags = tags.concat(this.normalizeAll(hashTags));\r\n            }\r\n        });\r\n\r\n        return _.uniq(tags);\r\n    }\r\n}\r\n\r\n\r\nangular\r\n    .module('pipTags', [])\r\n    .service('pipTags', Tags);\r\n","import { ITimerService } from './ITimerService';\r\n\r\nclass TimerEvent {\r\n    public event: string;\r\n    public timeout: number;\r\n    public interval: any;\r\n\r\n    public constructor(event: string, timeout: number) {\r\n        this.event = event;\r\n        this.timeout = timeout;\r\n    }\r\n}\r\n\r\n\r\nlet DefaultEvents: TimerEvent[] = [\r\n    new TimerEvent('pipAutoPullChanges', 60000), // 1 min\r\n    new TimerEvent('pipAutoUpdatePage', 15000), // 15 sec\r\n    new TimerEvent('pipAutoUpdateCollection', 300000) // 5 min\r\n];\r\n\r\n\r\nclass TimerService implements ITimerService {\r\n    private _rootScope: ng.IRootScopeService;\r\n    private _log: ng.ILogService;\r\n    private _interval: ng.IIntervalService;        \r\n    private _started = false;\r\n    private _events: TimerEvent[] = _.cloneDeep(DefaultEvents);\r\n\r\n    public constructor(\r\n        $rootScope: ng.IRootScopeService,\r\n        $log: ng.ILogService, \r\n        $interval: ng.IIntervalService\r\n    ) {\r\n        \"ngInject\";\r\n\r\n        this._rootScope = $rootScope;\r\n        this._log = $log;\r\n        this._interval = $interval;\r\n    }\r\n\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    public addEvent(event: string, timeout: number): void {\r\n        var existingEvent = _.find(this._events, (e) => e.event == event);\r\n        if (existingEvent != null) return;\r\n\r\n        let newEvent = <TimerEvent> {\r\n            event: event,\r\n            timeout: timeout\r\n        };\r\n        this._events.push(newEvent);\r\n\r\n        if (this._started)\r\n            this.startEvent(newEvent);\r\n    }\r\n\r\n    public removeEvent(event: string): void {\r\n        for (let i = this._events.length - 1; i >= 0; i--) {\r\n            let existingEvent = this._events[i];\r\n            if (existingEvent.event == event) {\r\n                this.stopEvent(existingEvent);\r\n                this._events.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public clearEvents(): void {\r\n        this.stop();\r\n        this._events = [];\r\n    }\r\n\r\n    private startEvent(event: TimerEvent): void {\r\n        event.interval = this._interval(\r\n            () => { \r\n                this._log.debug('Generated timer event ' + event.event); \r\n                this._rootScope.$emit(event.event)\r\n            },\r\n            event.timeout\r\n        )\r\n    }\r\n\r\n    private stopEvent(event: TimerEvent): void {\r\n        if (event.interval != null) {\r\n            try {\r\n                this._interval.cancel(event.interval);\r\n            } catch (ex) {\r\n                // Do nothing\r\n            }\r\n            event.interval = null;\r\n        }\r\n    }\r\n\r\n    public start(): void {\r\n        if (this._started) return;\r\n\r\n        _.each(this._events, (event) => {\r\n            this.startEvent(event);\r\n        });\r\n\r\n        this._started = true;\r\n    }\r\n\r\n    public stop(): void {\r\n        _.each(this._events, (event) => {\r\n            this.stopEvent(event);\r\n        });\r\n\r\n        this._started = false;\r\n    }\r\n}\r\n\r\n\r\nangular.module('pipTimer', [])\r\n    .service('pipTimer', TimerService);\r\n","import './Format';\r\nimport './TimerService';\r\nimport './ScrollService';\r\nimport './Tags';\r\nimport './Codes';\r\nimport './SystemInfo';\r\nimport './PageResetService';\r\n\r\n\r\nexport * from './IFormat';\r\nexport * from './ITimerService';\r\nexport * from './IScrollService';\r\nexport * from './ITags';\r\nexport * from './ICodes';\r\nexport * from './ISystemInfo';\r\nexport * from './IPageResetService';\r\n"]}